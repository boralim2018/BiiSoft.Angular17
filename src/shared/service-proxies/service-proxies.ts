//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IsTenantAvailableOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IsTenantAvailableOutput>;
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterOutput>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    resetPassword(body: ResetPasswordInput | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResetPasswordOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResetPasswordOutput>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResetPasswordOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    resolveTenantId(body: ResolveTenantIdInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    sendPasswordResetCode(body: SendPasswordResetCodeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    impersonate(body: ImpersonateInput | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Impersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonateOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonateOutput>;
        }));
    }

    protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackToImpersonator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackToImpersonator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonateOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonateOutput>;
        }));
    }

    protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    switchToLinkedAccount(body: SwitchToLinkedAccountInput | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwitchToLinkedAccountOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwitchToLinkedAccountOutput>;
        }));
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SwitchToLinkedAccountOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortMode (optional) 
     * @param usePagination (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAuditLogs(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, userName: string | undefined, serviceName: string | undefined, methodName: string | undefined, browserInfo: string | undefined, hasException: boolean | undefined, minExecutionDuration: number | undefined, maxExecutionDuration: number | undefined, keyword: string | undefined, sortField: string | undefined, sortMode: SortMode | undefined, usePagination: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AuditLogListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogs?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (serviceName === null)
            throw new Error("The parameter 'serviceName' cannot be null.");
        else if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&";
        if (methodName === null)
            throw new Error("The parameter 'methodName' cannot be null.");
        else if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&";
        if (browserInfo === null)
            throw new Error("The parameter 'browserInfo' cannot be null.");
        else if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&";
        if (hasException === null)
            throw new Error("The parameter 'hasException' cannot be null.");
        else if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&";
        if (minExecutionDuration === null)
            throw new Error("The parameter 'minExecutionDuration' cannot be null.");
        else if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&";
        if (maxExecutionDuration === null)
            throw new Error("The parameter 'maxExecutionDuration' cannot be null.");
        else if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortMode === null)
            throw new Error("The parameter 'sortMode' cannot be null.");
        else if (sortMode !== undefined)
            url_ += "SortMode=" + encodeURIComponent("" + sortMode) + "&";
        if (usePagination === null)
            throw new Error("The parameter 'usePagination' cannot be null.");
        else if (usePagination !== undefined)
            url_ += "UsePagination=" + encodeURIComponent("" + usePagination) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuditLogListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuditLogListDtoPagedResultDto>;
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<AuditLogListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuditLogListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    exportExcel(body: ExportAuditLogsInput | undefined): Observable<ExportFileOutput> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/ExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExportFileOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExportFileOutput>;
        }));
    }

    protected processExportExcel(response: HttpResponseBase): Observable<ExportFileOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BranchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateBranchInputDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Branch/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Branch/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    disable(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Branch/Disable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    enable(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Branch/Enable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    setAsDefault(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Branch/SetAsDefault";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAsDefault(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAsDefault(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetAsDefault(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    find(body: PageBranchInputDto | undefined): Observable<FindBranchDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Branch/Find";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFind(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFind(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FindBranchDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FindBranchDtoPagedResultDto>;
        }));
    }

    protected processFind(response: HttpResponseBase): Observable<FindBranchDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FindBranchDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getDetail(id: string | undefined): Observable<BranchDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/Branch/GetDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BranchDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BranchDetailDto>;
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<BranchDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BranchDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param creators_Exclude (optional) 
     * @param creators_Ids (optional) 
     * @param modifiers_Exclude (optional) 
     * @param modifiers_Ids (optional) 
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortMode (optional) 
     * @param usePagination (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getList(isActive: boolean | undefined, creators_Exclude: boolean | undefined, creators_Ids: number[] | undefined, modifiers_Exclude: boolean | undefined, modifiers_Ids: number[] | undefined, keyword: string | undefined, sortField: string | undefined, sortMode: SortMode | undefined, usePagination: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<BranchListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Branch/GetList?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (creators_Exclude === null)
            throw new Error("The parameter 'creators_Exclude' cannot be null.");
        else if (creators_Exclude !== undefined)
            url_ += "Creators.Exclude=" + encodeURIComponent("" + creators_Exclude) + "&";
        if (creators_Ids === null)
            throw new Error("The parameter 'creators_Ids' cannot be null.");
        else if (creators_Ids !== undefined)
            creators_Ids && creators_Ids.forEach(item => { url_ += "Creators.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (modifiers_Exclude === null)
            throw new Error("The parameter 'modifiers_Exclude' cannot be null.");
        else if (modifiers_Exclude !== undefined)
            url_ += "Modifiers.Exclude=" + encodeURIComponent("" + modifiers_Exclude) + "&";
        if (modifiers_Ids === null)
            throw new Error("The parameter 'modifiers_Ids' cannot be null.");
        else if (modifiers_Ids !== undefined)
            modifiers_Ids && modifiers_Ids.forEach(item => { url_ += "Modifiers.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortMode === null)
            throw new Error("The parameter 'sortMode' cannot be null.");
        else if (sortMode !== undefined)
            url_ += "SortMode=" + encodeURIComponent("" + sortMode) + "&";
        if (usePagination === null)
            throw new Error("The parameter 'usePagination' cannot be null.");
        else if (usePagination !== undefined)
            url_ += "UsePagination=" + encodeURIComponent("" + usePagination) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BranchListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BranchListDtoPagedResultDto>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<BranchListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BranchListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    exportExcel(body: ExportExcelBranchInputDto | undefined): Observable<ExportFileOutput> {
        let url_ = this.baseUrl + "/api/services/app/Branch/ExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExportFileOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExportFileOutput>;
        }));
    }

    protected processExportExcel(response: HttpResponseBase): Observable<ExportFileOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    exportExcelTemplate(): Observable<ExportFileOutput> {
        let url_ = this.baseUrl + "/api/services/app/Branch/ExportExcelTemplate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExportFileOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExportFileOutput>;
        }));
    }

    protected processExportExcelTemplate(response: HttpResponseBase): Observable<ExportFileOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    importExcel(body: FileTokenInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Branch/ImportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportExcel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateBranchInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Branch/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ChartOfAccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateChartOfAccountInputDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccount/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccount/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    disable(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccount/Disable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    enable(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccount/Enable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    find(body: FindChartOfAccountInputDto | undefined): Observable<FindChartOfAccountDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccount/Find";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFind(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFind(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FindChartOfAccountDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FindChartOfAccountDtoPagedResultDto>;
        }));
    }

    protected processFind(response: HttpResponseBase): Observable<FindChartOfAccountDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FindChartOfAccountDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getDetail(id: string | undefined): Observable<ChartOfAccountDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccount/GetDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChartOfAccountDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChartOfAccountDetailDto>;
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<ChartOfAccountDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChartOfAccountDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accountTypeFilter_Exclude (optional) 
     * @param accountTypeFilter_Ids (optional) 
     * @param subAccountTypeFilter_Exclude (optional) 
     * @param subAccountTypeFilter_Ids (optional) 
     * @param parentFilter_Exclude (optional) 
     * @param parentFilter_Ids (optional) 
     * @param isActive (optional) 
     * @param creators_Exclude (optional) 
     * @param creators_Ids (optional) 
     * @param modifiers_Exclude (optional) 
     * @param modifiers_Ids (optional) 
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortMode (optional) 
     * @param usePagination (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getList(accountTypeFilter_Exclude: boolean | undefined, accountTypeFilter_Ids: AccountType[] | undefined, subAccountTypeFilter_Exclude: boolean | undefined, subAccountTypeFilter_Ids: SubAccountType[] | undefined, parentFilter_Exclude: boolean | undefined, parentFilter_Ids: string[] | undefined, isActive: boolean | undefined, creators_Exclude: boolean | undefined, creators_Ids: number[] | undefined, modifiers_Exclude: boolean | undefined, modifiers_Ids: number[] | undefined, keyword: string | undefined, sortField: string | undefined, sortMode: SortMode | undefined, usePagination: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ChartOfAccountListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccount/GetList?";
        if (accountTypeFilter_Exclude === null)
            throw new Error("The parameter 'accountTypeFilter_Exclude' cannot be null.");
        else if (accountTypeFilter_Exclude !== undefined)
            url_ += "AccountTypeFilter.Exclude=" + encodeURIComponent("" + accountTypeFilter_Exclude) + "&";
        if (accountTypeFilter_Ids === null)
            throw new Error("The parameter 'accountTypeFilter_Ids' cannot be null.");
        else if (accountTypeFilter_Ids !== undefined)
            accountTypeFilter_Ids && accountTypeFilter_Ids.forEach(item => { url_ += "AccountTypeFilter.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (subAccountTypeFilter_Exclude === null)
            throw new Error("The parameter 'subAccountTypeFilter_Exclude' cannot be null.");
        else if (subAccountTypeFilter_Exclude !== undefined)
            url_ += "SubAccountTypeFilter.Exclude=" + encodeURIComponent("" + subAccountTypeFilter_Exclude) + "&";
        if (subAccountTypeFilter_Ids === null)
            throw new Error("The parameter 'subAccountTypeFilter_Ids' cannot be null.");
        else if (subAccountTypeFilter_Ids !== undefined)
            subAccountTypeFilter_Ids && subAccountTypeFilter_Ids.forEach(item => { url_ += "SubAccountTypeFilter.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (parentFilter_Exclude === null)
            throw new Error("The parameter 'parentFilter_Exclude' cannot be null.");
        else if (parentFilter_Exclude !== undefined)
            url_ += "ParentFilter.Exclude=" + encodeURIComponent("" + parentFilter_Exclude) + "&";
        if (parentFilter_Ids === null)
            throw new Error("The parameter 'parentFilter_Ids' cannot be null.");
        else if (parentFilter_Ids !== undefined)
            parentFilter_Ids && parentFilter_Ids.forEach(item => { url_ += "ParentFilter.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (creators_Exclude === null)
            throw new Error("The parameter 'creators_Exclude' cannot be null.");
        else if (creators_Exclude !== undefined)
            url_ += "Creators.Exclude=" + encodeURIComponent("" + creators_Exclude) + "&";
        if (creators_Ids === null)
            throw new Error("The parameter 'creators_Ids' cannot be null.");
        else if (creators_Ids !== undefined)
            creators_Ids && creators_Ids.forEach(item => { url_ += "Creators.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (modifiers_Exclude === null)
            throw new Error("The parameter 'modifiers_Exclude' cannot be null.");
        else if (modifiers_Exclude !== undefined)
            url_ += "Modifiers.Exclude=" + encodeURIComponent("" + modifiers_Exclude) + "&";
        if (modifiers_Ids === null)
            throw new Error("The parameter 'modifiers_Ids' cannot be null.");
        else if (modifiers_Ids !== undefined)
            modifiers_Ids && modifiers_Ids.forEach(item => { url_ += "Modifiers.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortMode === null)
            throw new Error("The parameter 'sortMode' cannot be null.");
        else if (sortMode !== undefined)
            url_ += "SortMode=" + encodeURIComponent("" + sortMode) + "&";
        if (usePagination === null)
            throw new Error("The parameter 'usePagination' cannot be null.");
        else if (usePagination !== undefined)
            url_ += "UsePagination=" + encodeURIComponent("" + usePagination) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChartOfAccountListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChartOfAccountListDtoPagedResultDto>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<ChartOfAccountListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChartOfAccountListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    exportExcel(body: ExportExcelChartOfAccountInputDto | undefined): Observable<ExportFileOutput> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccount/ExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExportFileOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExportFileOutput>;
        }));
    }

    protected processExportExcel(response: HttpResponseBase): Observable<ExportFileOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    exportExcelTemplate(): Observable<ExportFileOutput> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccount/ExportExcelTemplate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExportFileOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExportFileOutput>;
        }));
    }

    protected processExportExcelTemplate(response: HttpResponseBase): Observable<ExportFileOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    importExcel(body: FileTokenInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccount/ImportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportExcel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateChartOfAccountInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfAccount/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CityProvinceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateCityProvinceInputDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CityProvince/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CityProvince/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    disable(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CityProvince/Disable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    enable(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CityProvince/Enable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    find(body: PageCityProvinceInputDto | undefined): Observable<FindCityProvinceDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CityProvince/Find";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFind(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFind(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FindCityProvinceDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FindCityProvinceDtoPagedResultDto>;
        }));
    }

    protected processFind(response: HttpResponseBase): Observable<FindCityProvinceDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FindCityProvinceDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getDetail(id: string | undefined): Observable<CityProvinceDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/CityProvince/GetDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityProvinceDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityProvinceDetailDto>;
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<CityProvinceDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityProvinceDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param countries_Exclude (optional) 
     * @param countries_Ids (optional) 
     * @param isActive (optional) 
     * @param creators_Exclude (optional) 
     * @param creators_Ids (optional) 
     * @param modifiers_Exclude (optional) 
     * @param modifiers_Ids (optional) 
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortMode (optional) 
     * @param usePagination (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getList(countries_Exclude: boolean | undefined, countries_Ids: string[] | undefined, isActive: boolean | undefined, creators_Exclude: boolean | undefined, creators_Ids: number[] | undefined, modifiers_Exclude: boolean | undefined, modifiers_Ids: number[] | undefined, keyword: string | undefined, sortField: string | undefined, sortMode: SortMode | undefined, usePagination: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CityProvinceListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CityProvince/GetList?";
        if (countries_Exclude === null)
            throw new Error("The parameter 'countries_Exclude' cannot be null.");
        else if (countries_Exclude !== undefined)
            url_ += "Countries.Exclude=" + encodeURIComponent("" + countries_Exclude) + "&";
        if (countries_Ids === null)
            throw new Error("The parameter 'countries_Ids' cannot be null.");
        else if (countries_Ids !== undefined)
            countries_Ids && countries_Ids.forEach(item => { url_ += "Countries.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (creators_Exclude === null)
            throw new Error("The parameter 'creators_Exclude' cannot be null.");
        else if (creators_Exclude !== undefined)
            url_ += "Creators.Exclude=" + encodeURIComponent("" + creators_Exclude) + "&";
        if (creators_Ids === null)
            throw new Error("The parameter 'creators_Ids' cannot be null.");
        else if (creators_Ids !== undefined)
            creators_Ids && creators_Ids.forEach(item => { url_ += "Creators.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (modifiers_Exclude === null)
            throw new Error("The parameter 'modifiers_Exclude' cannot be null.");
        else if (modifiers_Exclude !== undefined)
            url_ += "Modifiers.Exclude=" + encodeURIComponent("" + modifiers_Exclude) + "&";
        if (modifiers_Ids === null)
            throw new Error("The parameter 'modifiers_Ids' cannot be null.");
        else if (modifiers_Ids !== undefined)
            modifiers_Ids && modifiers_Ids.forEach(item => { url_ += "Modifiers.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortMode === null)
            throw new Error("The parameter 'sortMode' cannot be null.");
        else if (sortMode !== undefined)
            url_ += "SortMode=" + encodeURIComponent("" + sortMode) + "&";
        if (usePagination === null)
            throw new Error("The parameter 'usePagination' cannot be null.");
        else if (usePagination !== undefined)
            url_ += "UsePagination=" + encodeURIComponent("" + usePagination) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityProvinceListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityProvinceListDtoPagedResultDto>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<CityProvinceListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityProvinceListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    exportExcel(body: ExportExcelCityProvinceInputDto | undefined): Observable<ExportFileOutput> {
        let url_ = this.baseUrl + "/api/services/app/CityProvince/ExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExportFileOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExportFileOutput>;
        }));
    }

    protected processExportExcel(response: HttpResponseBase): Observable<ExportFileOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    exportExcelTemplate(): Observable<ExportFileOutput> {
        let url_ = this.baseUrl + "/api/services/app/CityProvince/ExportExcelTemplate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExportFileOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExportFileOutput>;
        }));
    }

    protected processExportExcelTemplate(response: HttpResponseBase): Observable<ExportFileOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    importExcel(body: FileTokenInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CityProvince/ImportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportExcel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateCityProvinceInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CityProvince/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getAccountTypes(): Observable<AccountTypeNameValueDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetAccountTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountTypeNameValueDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountTypeNameValueDtoListResultDto>;
        }));
    }

    protected processGetAccountTypes(response: HttpResponseBase): Observable<AccountTypeNameValueDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountTypeNameValueDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accountTypeFilter_Exclude (optional) 
     * @param accountTypeFilter_Ids (optional) 
     * @return OK
     */
    getSubAccountTypes(accountTypeFilter_Exclude: boolean | undefined, accountTypeFilter_Ids: AccountType[] | undefined): Observable<SubAccountTypeNameValueDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetSubAccountTypes?";
        if (accountTypeFilter_Exclude === null)
            throw new Error("The parameter 'accountTypeFilter_Exclude' cannot be null.");
        else if (accountTypeFilter_Exclude !== undefined)
            url_ += "AccountTypeFilter.Exclude=" + encodeURIComponent("" + accountTypeFilter_Exclude) + "&";
        if (accountTypeFilter_Ids === null)
            throw new Error("The parameter 'accountTypeFilter_Ids' cannot be null.");
        else if (accountTypeFilter_Ids !== undefined)
            accountTypeFilter_Ids && accountTypeFilter_Ids.forEach(item => { url_ += "AccountTypeFilter.Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubAccountTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubAccountTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubAccountTypeNameValueDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubAccountTypeNameValueDtoListResultDto>;
        }));
    }

    protected processGetSubAccountTypes(response: HttpResponseBase): Observable<SubAccountTypeNameValueDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubAccountTypeNameValueDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param selectedTimeZones (optional) 
     * @param keyword (optional) 
     * @param usePagination (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getTimeZones(selectedTimeZones: string[] | undefined, keyword: string | undefined, usePagination: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<StringPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetTimeZones?";
        if (selectedTimeZones === null)
            throw new Error("The parameter 'selectedTimeZones' cannot be null.");
        else if (selectedTimeZones !== undefined)
            selectedTimeZones && selectedTimeZones.forEach(item => { url_ += "SelectedTimeZones=" + encodeURIComponent("" + item) + "&"; });
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (usePagination === null)
            throw new Error("The parameter 'usePagination' cannot be null.");
        else if (usePagination !== undefined)
            url_ += "UsePagination=" + encodeURIComponent("" + usePagination) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimeZones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimeZones(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringPagedResultDto>;
        }));
    }

    protected processGetTimeZones(response: HttpResponseBase): Observable<StringPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CompanySettingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createOrUpdateProfile(body: CreateUpdateBranchInputDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CompanySetting/CreateOrUpdateProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateOrUpdateProfile(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createOrUpdateGeneralSetting(body: CreateUpdateCompanyGeneralSettingInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/CompanySetting/CreateOrUpdateGeneralSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateGeneralSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateGeneralSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateOrUpdateGeneralSetting(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createOrUpdateAdvanceSetting(body: CreateUpdateCompanyAdvanceSettingInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/CompanySetting/CreateOrUpdateAdvanceSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateAdvanceSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateAdvanceSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateOrUpdateAdvanceSetting(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createOrUpdateAccountSetting(body: CreateUpdateCompanyAccountSettingInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/CompanySetting/CreateOrUpdateAccountSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateAccountSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateAccountSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateOrUpdateAccountSetting(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createOrUpdateTransactionNoSetting(body: CreateUpdateTransactionNoSettingInputDto[] | undefined): Observable<JournalTypeNameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CompanySetting/CreateOrUpdateTransactionNoSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateTransactionNoSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateTransactionNoSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JournalTypeNameValueDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JournalTypeNameValueDto[]>;
        }));
    }

    protected processCreateOrUpdateTransactionNoSetting(response: HttpResponseBase): Observable<JournalTypeNameValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(JournalTypeNameValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getDetail(): Observable<CompanySettingDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanySetting/GetDetail";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanySettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanySettingDto>;
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<CompanySettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanySettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CountryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateCountryInputDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Country/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Country/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    disable(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Country/Disable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    enable(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Country/Enable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    find(body: PageCountryInputDto | undefined): Observable<FindCountryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Country/Find";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFind(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFind(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FindCountryDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FindCountryDtoPagedResultDto>;
        }));
    }

    protected processFind(response: HttpResponseBase): Observable<FindCountryDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FindCountryDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getDetail(id: string | undefined): Observable<CountryDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/Country/GetDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDetailDto>;
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<CountryDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currencies_Exclude (optional) 
     * @param currencies_Ids (optional) 
     * @param isActive (optional) 
     * @param creators_Exclude (optional) 
     * @param creators_Ids (optional) 
     * @param modifiers_Exclude (optional) 
     * @param modifiers_Ids (optional) 
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortMode (optional) 
     * @param usePagination (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getList(currencies_Exclude: boolean | undefined, currencies_Ids: number[] | undefined, isActive: boolean | undefined, creators_Exclude: boolean | undefined, creators_Ids: number[] | undefined, modifiers_Exclude: boolean | undefined, modifiers_Ids: number[] | undefined, keyword: string | undefined, sortField: string | undefined, sortMode: SortMode | undefined, usePagination: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CountryListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Country/GetList?";
        if (currencies_Exclude === null)
            throw new Error("The parameter 'currencies_Exclude' cannot be null.");
        else if (currencies_Exclude !== undefined)
            url_ += "Currencies.Exclude=" + encodeURIComponent("" + currencies_Exclude) + "&";
        if (currencies_Ids === null)
            throw new Error("The parameter 'currencies_Ids' cannot be null.");
        else if (currencies_Ids !== undefined)
            currencies_Ids && currencies_Ids.forEach(item => { url_ += "Currencies.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (creators_Exclude === null)
            throw new Error("The parameter 'creators_Exclude' cannot be null.");
        else if (creators_Exclude !== undefined)
            url_ += "Creators.Exclude=" + encodeURIComponent("" + creators_Exclude) + "&";
        if (creators_Ids === null)
            throw new Error("The parameter 'creators_Ids' cannot be null.");
        else if (creators_Ids !== undefined)
            creators_Ids && creators_Ids.forEach(item => { url_ += "Creators.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (modifiers_Exclude === null)
            throw new Error("The parameter 'modifiers_Exclude' cannot be null.");
        else if (modifiers_Exclude !== undefined)
            url_ += "Modifiers.Exclude=" + encodeURIComponent("" + modifiers_Exclude) + "&";
        if (modifiers_Ids === null)
            throw new Error("The parameter 'modifiers_Ids' cannot be null.");
        else if (modifiers_Ids !== undefined)
            modifiers_Ids && modifiers_Ids.forEach(item => { url_ += "Modifiers.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortMode === null)
            throw new Error("The parameter 'sortMode' cannot be null.");
        else if (sortMode !== undefined)
            url_ += "SortMode=" + encodeURIComponent("" + sortMode) + "&";
        if (usePagination === null)
            throw new Error("The parameter 'usePagination' cannot be null.");
        else if (usePagination !== undefined)
            url_ += "UsePagination=" + encodeURIComponent("" + usePagination) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryListDtoPagedResultDto>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<CountryListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    exportExcel(body: ExportExcelCountryInputDto | undefined): Observable<ExportFileOutput> {
        let url_ = this.baseUrl + "/api/services/app/Country/ExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExportFileOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExportFileOutput>;
        }));
    }

    protected processExportExcel(response: HttpResponseBase): Observable<ExportFileOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    exportExcelTemplate(): Observable<ExportFileOutput> {
        let url_ = this.baseUrl + "/api/services/app/Country/ExportExcelTemplate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExportFileOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExportFileOutput>;
        }));
    }

    protected processExportExcelTemplate(response: HttpResponseBase): Observable<ExportFileOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    importExcel(body: FileTokenInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Country/ImportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportExcel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateCountryInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Country/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CurrencyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateCurrencyInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Currency/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Currency/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    disable(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Currency/Disable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    enable(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Currency/Enable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    setAsDefault(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Currency/SetAsDefault";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAsDefault(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAsDefault(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetAsDefault(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    find(body: PageCurrencyInputDto | undefined): Observable<FindCurrencyDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Currency/Find";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFind(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFind(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FindCurrencyDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FindCurrencyDtoPagedResultDto>;
        }));
    }

    protected processFind(response: HttpResponseBase): Observable<FindCurrencyDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FindCurrencyDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getDetail(id: number | undefined): Observable<CurrencyDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/Currency/GetDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrencyDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrencyDetailDto>;
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<CurrencyDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrencyDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param creators_Exclude (optional) 
     * @param creators_Ids (optional) 
     * @param modifiers_Exclude (optional) 
     * @param modifiers_Ids (optional) 
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortMode (optional) 
     * @param usePagination (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getList(isActive: boolean | undefined, creators_Exclude: boolean | undefined, creators_Ids: number[] | undefined, modifiers_Exclude: boolean | undefined, modifiers_Ids: number[] | undefined, keyword: string | undefined, sortField: string | undefined, sortMode: SortMode | undefined, usePagination: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CurrencyListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Currency/GetList?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (creators_Exclude === null)
            throw new Error("The parameter 'creators_Exclude' cannot be null.");
        else if (creators_Exclude !== undefined)
            url_ += "Creators.Exclude=" + encodeURIComponent("" + creators_Exclude) + "&";
        if (creators_Ids === null)
            throw new Error("The parameter 'creators_Ids' cannot be null.");
        else if (creators_Ids !== undefined)
            creators_Ids && creators_Ids.forEach(item => { url_ += "Creators.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (modifiers_Exclude === null)
            throw new Error("The parameter 'modifiers_Exclude' cannot be null.");
        else if (modifiers_Exclude !== undefined)
            url_ += "Modifiers.Exclude=" + encodeURIComponent("" + modifiers_Exclude) + "&";
        if (modifiers_Ids === null)
            throw new Error("The parameter 'modifiers_Ids' cannot be null.");
        else if (modifiers_Ids !== undefined)
            modifiers_Ids && modifiers_Ids.forEach(item => { url_ += "Modifiers.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortMode === null)
            throw new Error("The parameter 'sortMode' cannot be null.");
        else if (sortMode !== undefined)
            url_ += "SortMode=" + encodeURIComponent("" + sortMode) + "&";
        if (usePagination === null)
            throw new Error("The parameter 'usePagination' cannot be null.");
        else if (usePagination !== undefined)
            url_ += "UsePagination=" + encodeURIComponent("" + usePagination) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrencyListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrencyListDtoPagedResultDto>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<CurrencyListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrencyListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    exportExcel(body: ExportExcelCurrencyInputDto | undefined): Observable<ExportFileOutput> {
        let url_ = this.baseUrl + "/api/services/app/Currency/ExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExportFileOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExportFileOutput>;
        }));
    }

    protected processExportExcel(response: HttpResponseBase): Observable<ExportFileOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    exportExcelTemplate(): Observable<ExportFileOutput> {
        let url_ = this.baseUrl + "/api/services/app/Currency/ExportExcelTemplate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExportFileOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExportFileOutput>;
        }));
    }

    protected processExportExcelTemplate(response: HttpResponseBase): Observable<ExportFileOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    importExcel(body: FileTokenInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Currency/ImportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportExcel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateCurrencyInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Currency/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortMode (optional) 
     * @param usePagination (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getEditions(keyword: string | undefined, sortField: string | undefined, sortMode: SortMode | undefined, usePagination: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<EditionListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditions?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortMode === null)
            throw new Error("The parameter 'sortMode' cannot be null.");
        else if (sortMode !== undefined)
            url_ += "SortMode=" + encodeURIComponent("" + sortMode) + "&";
        if (usePagination === null)
            throw new Error("The parameter 'usePagination' cannot be null.");
        else if (usePagination !== undefined)
            url_ += "UsePagination=" + encodeURIComponent("" + usePagination) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EditionListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EditionListDtoPagedResultDto>;
        }));
    }

    protected processGetEditions(response: HttpResponseBase): Observable<EditionListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EditionListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getEditionForEdit(id: number | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEditionEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEditionEditOutput>;
        }));
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEditionEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getFeatures(): Observable<FlatFeatureDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetFeatures";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFeatures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FlatFeatureDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FlatFeatureDtoListResultDto>;
        }));
    }

    protected processGetFeatures(response: HttpResponseBase): Observable<FlatFeatureDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FlatFeatureDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createOrUpdateEdition(body: CreateOrUpdateEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/CreateOrUpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteEdition(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/DeleteEdition?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param selectedEditionId (optional) 
     * @param addAllItem (optional) 
     * @return OK
     */
    getEditionComboboxItems(selectedEditionId: number | undefined, addAllItem: boolean | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionComboboxItems?";
        if (selectedEditionId === null)
            throw new Error("The parameter 'selectedEditionId' cannot be null.");
        else if (selectedEditionId !== undefined)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&";
        if (addAllItem === null)
            throw new Error("The parameter 'addAllItem' cannot be null.");
        else if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboboxItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboboxItemDto[]>;
        }));
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ComboboxItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HostSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HostSettingsEditDto>;
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HostSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateAllSettings(body: HostSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class KhanDistrictServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateKhanDistrictInputDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/KhanDistrict/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KhanDistrict/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    disable(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KhanDistrict/Disable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    enable(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KhanDistrict/Enable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    find(body: PageKhanDistrictInputDto | undefined): Observable<FindKhanDistrictDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/KhanDistrict/Find";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFind(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFind(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FindKhanDistrictDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FindKhanDistrictDtoPagedResultDto>;
        }));
    }

    protected processFind(response: HttpResponseBase): Observable<FindKhanDistrictDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FindKhanDistrictDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getDetail(id: string | undefined): Observable<KhanDistrictDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/KhanDistrict/GetDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KhanDistrictDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KhanDistrictDetailDto>;
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<KhanDistrictDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KhanDistrictDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param countries_Exclude (optional) 
     * @param countries_Ids (optional) 
     * @param cityProvinces_Exclude (optional) 
     * @param cityProvinces_Ids (optional) 
     * @param isActive (optional) 
     * @param creators_Exclude (optional) 
     * @param creators_Ids (optional) 
     * @param modifiers_Exclude (optional) 
     * @param modifiers_Ids (optional) 
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortMode (optional) 
     * @param usePagination (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getList(countries_Exclude: boolean | undefined, countries_Ids: string[] | undefined, cityProvinces_Exclude: boolean | undefined, cityProvinces_Ids: string[] | undefined, isActive: boolean | undefined, creators_Exclude: boolean | undefined, creators_Ids: number[] | undefined, modifiers_Exclude: boolean | undefined, modifiers_Ids: number[] | undefined, keyword: string | undefined, sortField: string | undefined, sortMode: SortMode | undefined, usePagination: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<KhanDistrictListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/KhanDistrict/GetList?";
        if (countries_Exclude === null)
            throw new Error("The parameter 'countries_Exclude' cannot be null.");
        else if (countries_Exclude !== undefined)
            url_ += "Countries.Exclude=" + encodeURIComponent("" + countries_Exclude) + "&";
        if (countries_Ids === null)
            throw new Error("The parameter 'countries_Ids' cannot be null.");
        else if (countries_Ids !== undefined)
            countries_Ids && countries_Ids.forEach(item => { url_ += "Countries.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (cityProvinces_Exclude === null)
            throw new Error("The parameter 'cityProvinces_Exclude' cannot be null.");
        else if (cityProvinces_Exclude !== undefined)
            url_ += "CityProvinces.Exclude=" + encodeURIComponent("" + cityProvinces_Exclude) + "&";
        if (cityProvinces_Ids === null)
            throw new Error("The parameter 'cityProvinces_Ids' cannot be null.");
        else if (cityProvinces_Ids !== undefined)
            cityProvinces_Ids && cityProvinces_Ids.forEach(item => { url_ += "CityProvinces.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (creators_Exclude === null)
            throw new Error("The parameter 'creators_Exclude' cannot be null.");
        else if (creators_Exclude !== undefined)
            url_ += "Creators.Exclude=" + encodeURIComponent("" + creators_Exclude) + "&";
        if (creators_Ids === null)
            throw new Error("The parameter 'creators_Ids' cannot be null.");
        else if (creators_Ids !== undefined)
            creators_Ids && creators_Ids.forEach(item => { url_ += "Creators.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (modifiers_Exclude === null)
            throw new Error("The parameter 'modifiers_Exclude' cannot be null.");
        else if (modifiers_Exclude !== undefined)
            url_ += "Modifiers.Exclude=" + encodeURIComponent("" + modifiers_Exclude) + "&";
        if (modifiers_Ids === null)
            throw new Error("The parameter 'modifiers_Ids' cannot be null.");
        else if (modifiers_Ids !== undefined)
            modifiers_Ids && modifiers_Ids.forEach(item => { url_ += "Modifiers.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortMode === null)
            throw new Error("The parameter 'sortMode' cannot be null.");
        else if (sortMode !== undefined)
            url_ += "SortMode=" + encodeURIComponent("" + sortMode) + "&";
        if (usePagination === null)
            throw new Error("The parameter 'usePagination' cannot be null.");
        else if (usePagination !== undefined)
            url_ += "UsePagination=" + encodeURIComponent("" + usePagination) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KhanDistrictListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KhanDistrictListDtoPagedResultDto>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<KhanDistrictListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KhanDistrictListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    exportExcel(body: ExportExcelKhanDistrictInputDto | undefined): Observable<ExportFileOutput> {
        let url_ = this.baseUrl + "/api/services/app/KhanDistrict/ExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExportFileOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExportFileOutput>;
        }));
    }

    protected processExportExcel(response: HttpResponseBase): Observable<ExportFileOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    exportExcelTemplate(): Observable<ExportFileOutput> {
        let url_ = this.baseUrl + "/api/services/app/KhanDistrict/ExportExcelTemplate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExportFileOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExportFileOutput>;
        }));
    }

    protected processExportExcelTemplate(response: HttpResponseBase): Observable<ExportFileOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    importExcel(body: FileTokenInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KhanDistrict/ImportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportExcel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateKhanDistrictInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KhanDistrict/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortMode (optional) 
     * @param usePagination (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getLanguages(keyword: string | undefined, sortField: string | undefined, sortMode: SortMode | undefined, usePagination: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedLanguagesResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguages?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortMode === null)
            throw new Error("The parameter 'sortMode' cannot be null.");
        else if (sortMode !== undefined)
            url_ += "SortMode=" + encodeURIComponent("" + sortMode) + "&";
        if (usePagination === null)
            throw new Error("The parameter 'usePagination' cannot be null.");
        else if (usePagination !== undefined)
            url_ += "UsePagination=" + encodeURIComponent("" + usePagination) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedLanguagesResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedLanguagesResultDto>;
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<PagedLanguagesResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedLanguagesResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getLanguageForEdit(id: number | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetLanguageForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetLanguageForEditOutput>;
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLanguageForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createOrUpdateLanguage(body: CreateOrUpdateLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteLanguage(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    enable(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/Enable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    disable(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/Disable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    setDefaultLanguage(body: SetDefaultLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param baseLanguageName (optional) 
     * @param targetValueFilter (optional) 
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortMode (optional) 
     * @param usePagination (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getLanguageTexts(sourceName: string, baseLanguageName: string | undefined, targetLanguageName: string, targetValueFilter: string | undefined, keyword: string | undefined, sortField: string | undefined, sortMode: SortMode | undefined, usePagination: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<LanguageTextListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageTexts?";
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "SourceName=" + encodeURIComponent("" + sourceName) + "&";
        if (baseLanguageName === null)
            throw new Error("The parameter 'baseLanguageName' cannot be null.");
        else if (baseLanguageName !== undefined)
            url_ += "BaseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&";
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "TargetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&";
        if (targetValueFilter === null)
            throw new Error("The parameter 'targetValueFilter' cannot be null.");
        else if (targetValueFilter !== undefined)
            url_ += "TargetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortMode === null)
            throw new Error("The parameter 'sortMode' cannot be null.");
        else if (sortMode !== undefined)
            url_ += "SortMode=" + encodeURIComponent("" + sortMode) + "&";
        if (usePagination === null)
            throw new Error("The parameter 'usePagination' cannot be null.");
        else if (usePagination !== undefined)
            url_ += "UsePagination=" + encodeURIComponent("" + usePagination) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LanguageTextListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LanguageTextListDtoPagedResultDto>;
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<LanguageTextListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LanguageTextListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateLanguageText(body: UpdateLanguageTextInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LocationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateLocationInputDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Location/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Location/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    disable(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Location/Disable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    enable(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Location/Enable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    find(body: PageLocationInputDto | undefined): Observable<FindLocationDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Location/Find";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFind(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFind(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FindLocationDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FindLocationDtoPagedResultDto>;
        }));
    }

    protected processFind(response: HttpResponseBase): Observable<FindLocationDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FindLocationDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getDetail(id: string | undefined): Observable<LocationDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/Location/GetDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LocationDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LocationDetailDto>;
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<LocationDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocationDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param creators_Exclude (optional) 
     * @param creators_Ids (optional) 
     * @param modifiers_Exclude (optional) 
     * @param modifiers_Ids (optional) 
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortMode (optional) 
     * @param usePagination (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getList(isActive: boolean | undefined, creators_Exclude: boolean | undefined, creators_Ids: number[] | undefined, modifiers_Exclude: boolean | undefined, modifiers_Ids: number[] | undefined, keyword: string | undefined, sortField: string | undefined, sortMode: SortMode | undefined, usePagination: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<LocationListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Location/GetList?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (creators_Exclude === null)
            throw new Error("The parameter 'creators_Exclude' cannot be null.");
        else if (creators_Exclude !== undefined)
            url_ += "Creators.Exclude=" + encodeURIComponent("" + creators_Exclude) + "&";
        if (creators_Ids === null)
            throw new Error("The parameter 'creators_Ids' cannot be null.");
        else if (creators_Ids !== undefined)
            creators_Ids && creators_Ids.forEach(item => { url_ += "Creators.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (modifiers_Exclude === null)
            throw new Error("The parameter 'modifiers_Exclude' cannot be null.");
        else if (modifiers_Exclude !== undefined)
            url_ += "Modifiers.Exclude=" + encodeURIComponent("" + modifiers_Exclude) + "&";
        if (modifiers_Ids === null)
            throw new Error("The parameter 'modifiers_Ids' cannot be null.");
        else if (modifiers_Ids !== undefined)
            modifiers_Ids && modifiers_Ids.forEach(item => { url_ += "Modifiers.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortMode === null)
            throw new Error("The parameter 'sortMode' cannot be null.");
        else if (sortMode !== undefined)
            url_ += "SortMode=" + encodeURIComponent("" + sortMode) + "&";
        if (usePagination === null)
            throw new Error("The parameter 'usePagination' cannot be null.");
        else if (usePagination !== undefined)
            url_ += "UsePagination=" + encodeURIComponent("" + usePagination) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LocationListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LocationListDtoPagedResultDto>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<LocationListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocationListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    exportExcel(body: ExportExcelLocationInputDto | undefined): Observable<ExportFileOutput> {
        let url_ = this.baseUrl + "/api/services/app/Location/ExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExportFileOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExportFileOutput>;
        }));
    }

    protected processExportExcel(response: HttpResponseBase): Observable<ExportFileOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    exportExcelTemplate(): Observable<ExportFileOutput> {
        let url_ = this.baseUrl + "/api/services/app/Location/ExportExcelTemplate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExportFileOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExportFileOutput>;
        }));
    }

    protected processExportExcelTemplate(response: HttpResponseBase): Observable<ExportFileOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    importExcel(body: FileTokenInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Location/ImportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportExcel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateLocationInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Location/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getOrganizationUnits(): Observable<OrganizationUnitDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitDtoListResultDto>;
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<OrganizationUnitDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param sortField (optional) 
     * @param sortMode (optional) 
     * @param usePagination (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getOrganizationUnitUsers(id: number | undefined, sortField: string | undefined, sortMode: SortMode | undefined, usePagination: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<OrganizationUnitUserListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortMode === null)
            throw new Error("The parameter 'sortMode' cannot be null.");
        else if (sortMode !== undefined)
            url_ += "SortMode=" + encodeURIComponent("" + sortMode) + "&";
        if (usePagination === null)
            throw new Error("The parameter 'usePagination' cannot be null.");
        else if (usePagination !== undefined)
            url_ += "UsePagination=" + encodeURIComponent("" + usePagination) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitUserListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitUserListDtoPagedResultDto>;
        }));
    }

    protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<OrganizationUnitUserListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitUserListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createOrganizationUnit(body: CreateOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitDto>;
        }));
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateOrganizationUnit(body: UpdateOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitDto>;
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    moveOrganizationUnit(body: MoveOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitDto>;
        }));
    }

    protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteOrganizationUnit(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/DeleteOrganizationUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param organizationUnitId (optional) 
     * @return OK
     */
    removeUserFromOrganizationUnit(userId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addUsersToOrganizationUnit(body: UsersToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsersToOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    findUsers(body: FindOrganizationUnitUsersInput | undefined): Observable<NameValueDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NameValueDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NameValueDtoPagedResultDto>;
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<NameValueDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NameValueDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentUserProfileEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentUserProfileEditDto>;
        }));
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentUserProfileEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateGoogleAuthenticatorKey(): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGoogleAuthenticatorKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGoogleAuthenticatorKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateGoogleAuthenticatorKeyOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateGoogleAuthenticatorKeyOutput>;
        }));
    }

    protected processUpdateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    sendVerificationSms(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/SendVerificationSms";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendVerificationSms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendVerificationSms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendVerificationSms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    verifySmsCode(body: VerifySmsCodeInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/VerifySmsCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySmsCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySmsCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processVerifySmsCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateCurrentUserProfile(body: CurrentUserProfileEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    changePassword(body: ChangePasswordInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetPasswordComplexitySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordComplexitySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPasswordComplexitySettingOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPasswordComplexitySettingOutput>;
        }));
    }

    protected processGetPasswordComplexitySetting(response: HttpResponseBase): Observable<GetPasswordComplexitySettingOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPasswordComplexitySettingOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateRoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param permission (optional) 
     * @return OK
     */
    getRoles(permission: string | undefined): Observable<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission === null)
            throw new Error("The parameter 'permission' cannot be null.");
        else if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleListDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleListDtoListResultDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleListDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortMode (optional) 
     * @param usePagination (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(keyword: string | undefined, sortField: string | undefined, sortMode: SortMode | undefined, usePagination: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortMode === null)
            throw new Error("The parameter 'sortMode' cannot be null.");
        else if (sortMode !== undefined)
            url_ += "SortMode=" + encodeURIComponent("" + sortMode) + "&";
        if (usePagination === null)
            throw new Error("The parameter 'usePagination' cannot be null.");
        else if (usePagination !== undefined)
            url_ += "UsePagination=" + encodeURIComponent("" + usePagination) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAllPermissions(): Observable<PermissionDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoListResultDto>;
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRoleForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRoleForEditOutput>;
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SangkatCommuneServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateSangkatCommuneInputDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SangkatCommune/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SangkatCommune/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    disable(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SangkatCommune/Disable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    enable(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SangkatCommune/Enable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    find(body: PageSangkatCommuneInputDto | undefined): Observable<FindSangkatCommuneDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SangkatCommune/Find";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFind(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFind(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FindSangkatCommuneDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FindSangkatCommuneDtoPagedResultDto>;
        }));
    }

    protected processFind(response: HttpResponseBase): Observable<FindSangkatCommuneDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FindSangkatCommuneDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getDetail(id: string | undefined): Observable<SangkatCommuneDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/SangkatCommune/GetDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SangkatCommuneDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SangkatCommuneDetailDto>;
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<SangkatCommuneDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SangkatCommuneDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param countries_Exclude (optional) 
     * @param countries_Ids (optional) 
     * @param cityProvinces_Exclude (optional) 
     * @param cityProvinces_Ids (optional) 
     * @param khanDistricts_Exclude (optional) 
     * @param khanDistricts_Ids (optional) 
     * @param isActive (optional) 
     * @param creators_Exclude (optional) 
     * @param creators_Ids (optional) 
     * @param modifiers_Exclude (optional) 
     * @param modifiers_Ids (optional) 
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortMode (optional) 
     * @param usePagination (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getList(countries_Exclude: boolean | undefined, countries_Ids: string[] | undefined, cityProvinces_Exclude: boolean | undefined, cityProvinces_Ids: string[] | undefined, khanDistricts_Exclude: boolean | undefined, khanDistricts_Ids: string[] | undefined, isActive: boolean | undefined, creators_Exclude: boolean | undefined, creators_Ids: number[] | undefined, modifiers_Exclude: boolean | undefined, modifiers_Ids: number[] | undefined, keyword: string | undefined, sortField: string | undefined, sortMode: SortMode | undefined, usePagination: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<SangkatCommuneListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SangkatCommune/GetList?";
        if (countries_Exclude === null)
            throw new Error("The parameter 'countries_Exclude' cannot be null.");
        else if (countries_Exclude !== undefined)
            url_ += "Countries.Exclude=" + encodeURIComponent("" + countries_Exclude) + "&";
        if (countries_Ids === null)
            throw new Error("The parameter 'countries_Ids' cannot be null.");
        else if (countries_Ids !== undefined)
            countries_Ids && countries_Ids.forEach(item => { url_ += "Countries.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (cityProvinces_Exclude === null)
            throw new Error("The parameter 'cityProvinces_Exclude' cannot be null.");
        else if (cityProvinces_Exclude !== undefined)
            url_ += "CityProvinces.Exclude=" + encodeURIComponent("" + cityProvinces_Exclude) + "&";
        if (cityProvinces_Ids === null)
            throw new Error("The parameter 'cityProvinces_Ids' cannot be null.");
        else if (cityProvinces_Ids !== undefined)
            cityProvinces_Ids && cityProvinces_Ids.forEach(item => { url_ += "CityProvinces.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (khanDistricts_Exclude === null)
            throw new Error("The parameter 'khanDistricts_Exclude' cannot be null.");
        else if (khanDistricts_Exclude !== undefined)
            url_ += "KhanDistricts.Exclude=" + encodeURIComponent("" + khanDistricts_Exclude) + "&";
        if (khanDistricts_Ids === null)
            throw new Error("The parameter 'khanDistricts_Ids' cannot be null.");
        else if (khanDistricts_Ids !== undefined)
            khanDistricts_Ids && khanDistricts_Ids.forEach(item => { url_ += "KhanDistricts.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (creators_Exclude === null)
            throw new Error("The parameter 'creators_Exclude' cannot be null.");
        else if (creators_Exclude !== undefined)
            url_ += "Creators.Exclude=" + encodeURIComponent("" + creators_Exclude) + "&";
        if (creators_Ids === null)
            throw new Error("The parameter 'creators_Ids' cannot be null.");
        else if (creators_Ids !== undefined)
            creators_Ids && creators_Ids.forEach(item => { url_ += "Creators.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (modifiers_Exclude === null)
            throw new Error("The parameter 'modifiers_Exclude' cannot be null.");
        else if (modifiers_Exclude !== undefined)
            url_ += "Modifiers.Exclude=" + encodeURIComponent("" + modifiers_Exclude) + "&";
        if (modifiers_Ids === null)
            throw new Error("The parameter 'modifiers_Ids' cannot be null.");
        else if (modifiers_Ids !== undefined)
            modifiers_Ids && modifiers_Ids.forEach(item => { url_ += "Modifiers.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortMode === null)
            throw new Error("The parameter 'sortMode' cannot be null.");
        else if (sortMode !== undefined)
            url_ += "SortMode=" + encodeURIComponent("" + sortMode) + "&";
        if (usePagination === null)
            throw new Error("The parameter 'usePagination' cannot be null.");
        else if (usePagination !== undefined)
            url_ += "UsePagination=" + encodeURIComponent("" + usePagination) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SangkatCommuneListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SangkatCommuneListDtoPagedResultDto>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<SangkatCommuneListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SangkatCommuneListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    exportExcel(body: ExportExcelSangkatCommuneInputDto | undefined): Observable<ExportFileOutput> {
        let url_ = this.baseUrl + "/api/services/app/SangkatCommune/ExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExportFileOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExportFileOutput>;
        }));
    }

    protected processExportExcel(response: HttpResponseBase): Observable<ExportFileOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    exportExcelTemplate(): Observable<ExportFileOutput> {
        let url_ = this.baseUrl + "/api/services/app/SangkatCommune/ExportExcelTemplate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExportFileOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExportFileOutput>;
        }));
    }

    protected processExportExcelTemplate(response: HttpResponseBase): Observable<ExportFileOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    importExcel(body: FileTokenInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SangkatCommune/ImportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportExcel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateSangkatCommuneInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SangkatCommune/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCurrentLoginInformationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCurrentLoginInformationsOutput>;
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortMode (optional) 
     * @param usePagination (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(isActive: boolean | undefined, keyword: string | undefined, sortField: string | undefined, sortMode: SortMode | undefined, usePagination: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortMode === null)
            throw new Error("The parameter 'sortMode' cannot be null.");
        else if (sortMode !== undefined)
            url_ += "SortMode=" + encodeURIComponent("" + sortMode) + "&";
        if (usePagination === null)
            throw new Error("The parameter 'usePagination' cannot be null.");
        else if (usePagination !== undefined)
            url_ += "UsePagination=" + encodeURIComponent("" + usePagination) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TenantDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateTenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: TenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getTenantFeaturesForEdit(id: number | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantFeaturesForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTenantFeaturesEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTenantFeaturesEditOutput>;
        }));
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTenantFeaturesEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateTenantFeatures(body: UpdateTenantFeaturesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    resetTenantSpecificFeatures(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    enable(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Enable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    disable(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Disable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param to (optional) 
     * @param subject (optional) 
     * @param message (optional) 
     * @param bodyHtml (optional) 
     * @return OK
     */
    testSendMail(to: string | undefined, subject: string | undefined, message: string | undefined, bodyHtml: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Test/TestSendMail?";
        if (to === null)
            throw new Error("The parameter 'to' cannot be null.");
        else if (to !== undefined)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        if (subject === null)
            throw new Error("The parameter 'subject' cannot be null.");
        else if (subject !== undefined)
            url_ += "subject=" + encodeURIComponent("" + subject) + "&";
        if (message === null)
            throw new Error("The parameter 'message' cannot be null.");
        else if (message !== undefined)
            url_ += "message=" + encodeURIComponent("" + message) + "&";
        if (bodyHtml === null)
            throw new Error("The parameter 'bodyHtml' cannot be null.");
        else if (bodyHtml !== undefined)
            url_ += "bodyHtml=" + encodeURIComponent("" + bodyHtml) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestSendMail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestSendMail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestSendMail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    pdfBacord(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Test/PdfBacord";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPdfBacord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPdfBacord(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPdfBacord(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    testPdf(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Test/TestPdf";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestPdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestPdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestPdf(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    testHangfire(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Test/TestHangfire";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestHangfire(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestHangfire(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestHangfire(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param records (optional) 
     * @return OK
     */
    testBulkInsert(records: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Test/TestBulkInsert?";
        if (records === null)
            throw new Error("The parameter 'records' cannot be null.");
        else if (records !== undefined)
            url_ += "records=" + encodeURIComponent("" + records) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestBulkInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestBulkInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processTestBulkInsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param orderBy (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @return OK
     */
    getLinqSkipTake(orderBy: string | undefined, skip: number | undefined, take: number | undefined): Observable<TestModelOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/Test/GetLinqSkipTake?";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinqSkipTake(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinqSkipTake(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TestModelOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TestModelOutput[]>;
        }));
    }

    protected processGetLinqSkipTake(response: HttpResponseBase): Observable<TestModelOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TestModelOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    timeZones(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Test/TimeZones";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTimeZones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTimeZones(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processTimeZones(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param defaultTimezoneScope (optional) 
     * @return OK
     */
    getTimezones(defaultTimezoneScope: SettingScopes | undefined): Observable<NameValueDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezones?";
        if (defaultTimezoneScope === null)
            throw new Error("The parameter 'defaultTimezoneScope' cannot be null.");
        else if (defaultTimezoneScope !== undefined)
            url_ += "DefaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NameValueDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NameValueDtoListResultDto>;
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<NameValueDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NameValueDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param selectedTimezoneId (optional) 
     * @return OK
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId === null)
            throw new Error("The parameter 'selectedTimezoneId' cannot be null.");
        else if (selectedTimezoneId !== undefined)
            url_ += "SelectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboboxItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboboxItemDto[]>;
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ComboboxItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param switchAccountToken (optional) 
     * @return OK
     */
    linkedAccountAuthenticate(switchAccountToken: string | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken === null)
            throw new Error("The parameter 'switchAccountToken' cannot be null.");
        else if (switchAccountToken !== undefined)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkedAccountAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkedAccountAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwitchedAccountAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwitchedAccountAuthenticateResultModel>;
        }));
    }

    protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SwitchedAccountAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param impersonationToken (optional) 
     * @return OK
     */
    impersonatedAuthenticate(impersonationToken: string | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (impersonationToken === null)
            throw new Error("The parameter 'impersonationToken' cannot be null.");
        else if (impersonationToken !== undefined)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonatedAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonatedAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonatedAuthenticateResultModel>;
        }));
    }

    protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonatedAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    logOut(): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/LogOut";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginProviderInfoModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginProviderInfoModel[]>;
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalAuthenticateResultModel>;
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    bulkInsert(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Unit/BulkInsert";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processBulkInsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    bulkDelete(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Unit/BulkDelete";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBulkDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    bulkSoftDelete(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Unit/BulkSoftDelete";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkSoftDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkSoftDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBulkSoftDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    testDate(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Unit/TestDate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestDate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    testSetting(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Unit/TestSetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestSetting(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    find(body: PagedActiveSortFilterInputDto | undefined): Observable<UnitDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Unit/Find";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFind(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFind(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitDtoPagedResultDto>;
        }));
    }

    protected processFind(response: HttpResponseBase): Observable<UnitDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UnitDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    testPdf(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Unit/TestPdf";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestPdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestPdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestPdf(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param productKey (optional) 
     * @return OK
     */
    generateLicenseKey(productKey: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Unit/GenerateLicenseKey?";
        if (productKey === null)
            throw new Error("The parameter 'productKey' cannot be null.");
        else if (productKey !== undefined)
            url_ += "productKey=" + encodeURIComponent("" + productKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateLicenseKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateLicenseKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGenerateLicenseKey(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    findUsers(body: FindUsersInput | undefined): Observable<UserSummaryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserSummaryDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserSummaryDtoPagedResultDto>;
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<UserSummaryDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSummaryDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortMode (optional) 
     * @param usePagination (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getAll(isActive: boolean | undefined, keyword: string | undefined, sortField: string | undefined, sortMode: SortMode | undefined, usePagination: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortMode === null)
            throw new Error("The parameter 'sortMode' cannot be null.");
        else if (sortMode !== undefined)
            url_ += "SortMode=" + encodeURIComponent("" + sortMode) + "&";
        if (usePagination === null)
            throw new Error("The parameter 'usePagination' cannot be null.");
        else if (usePagination !== undefined)
            url_ += "UsePagination=" + encodeURIComponent("" + usePagination) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    enable(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Enable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    disable(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Disable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    activate(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deactivate(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Deactivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeactivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeactivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getRoles(): Observable<RoleDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoListResultDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getUserPermissionsForEdit(id: number | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserPermissionsForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserPermissionsForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserPermissionsForEditOutput>;
        }));
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserPermissionsForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateUserPermissions(body: UpdateUserPermissionsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUserPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    resetUserSpecificPermissions(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetUserSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetUserSpecificPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserSpecificPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetUserSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    linkToUser(body: LinkToUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sortField (optional) 
     * @param sortMode (optional) 
     * @param usePagination (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getLinkedUsers(sortField: string | undefined, sortMode: SortMode | undefined, usePagination: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<LinkedUserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetLinkedUsers?";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortMode === null)
            throw new Error("The parameter 'sortMode' cannot be null.");
        else if (sortMode !== undefined)
            url_ += "SortMode=" + encodeURIComponent("" + sortMode) + "&";
        if (usePagination === null)
            throw new Error("The parameter 'usePagination' cannot be null.");
        else if (usePagination !== undefined)
            url_ += "UsePagination=" + encodeURIComponent("" + usePagination) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LinkedUserDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LinkedUserDtoPagedResultDto>;
        }));
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<LinkedUserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LinkedUserDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getRecentlyUsedLinkedUsers(): Observable<LinkedUserDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LinkedUserDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LinkedUserDtoListResultDto>;
        }));
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<LinkedUserDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LinkedUserDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    unlinkUser(body: UnlinkUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getRecentUserLoginAttempts(): Observable<UserLoginAttemptDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLogin/GetRecentUserLoginAttempts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUserLoginAttempts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserLoginAttemptDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserLoginAttemptDtoListResultDto>;
        }));
    }

    protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<UserLoginAttemptDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserLoginAttemptDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param input (optional) 
     * @return OK
     */
    updateUIEnable(input: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserSettings/UpdateUIEnable?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUIEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUIEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUIEnable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class VillageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateUpdateVillageInputDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Village/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Village/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    disable(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Village/Disable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    enable(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Village/Enable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    find(body: PageVillageInputDto | undefined): Observable<FindVillageDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Village/Find";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFind(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFind(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FindVillageDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FindVillageDtoPagedResultDto>;
        }));
    }

    protected processFind(response: HttpResponseBase): Observable<FindVillageDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FindVillageDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getDetail(id: string | undefined): Observable<VillageDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/Village/GetDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VillageDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VillageDetailDto>;
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<VillageDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VillageDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param countries_Exclude (optional) 
     * @param countries_Ids (optional) 
     * @param cityProvinces_Exclude (optional) 
     * @param cityProvinces_Ids (optional) 
     * @param khanDistricts_Exclude (optional) 
     * @param khanDistricts_Ids (optional) 
     * @param sangkatCommunes_Exclude (optional) 
     * @param sangkatCommunes_Ids (optional) 
     * @param isActive (optional) 
     * @param creators_Exclude (optional) 
     * @param creators_Ids (optional) 
     * @param modifiers_Exclude (optional) 
     * @param modifiers_Ids (optional) 
     * @param keyword (optional) 
     * @param sortField (optional) 
     * @param sortMode (optional) 
     * @param usePagination (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return OK
     */
    getList(countries_Exclude: boolean | undefined, countries_Ids: string[] | undefined, cityProvinces_Exclude: boolean | undefined, cityProvinces_Ids: string[] | undefined, khanDistricts_Exclude: boolean | undefined, khanDistricts_Ids: string[] | undefined, sangkatCommunes_Exclude: boolean | undefined, sangkatCommunes_Ids: string[] | undefined, isActive: boolean | undefined, creators_Exclude: boolean | undefined, creators_Ids: number[] | undefined, modifiers_Exclude: boolean | undefined, modifiers_Ids: number[] | undefined, keyword: string | undefined, sortField: string | undefined, sortMode: SortMode | undefined, usePagination: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<VillageListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Village/GetList?";
        if (countries_Exclude === null)
            throw new Error("The parameter 'countries_Exclude' cannot be null.");
        else if (countries_Exclude !== undefined)
            url_ += "Countries.Exclude=" + encodeURIComponent("" + countries_Exclude) + "&";
        if (countries_Ids === null)
            throw new Error("The parameter 'countries_Ids' cannot be null.");
        else if (countries_Ids !== undefined)
            countries_Ids && countries_Ids.forEach(item => { url_ += "Countries.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (cityProvinces_Exclude === null)
            throw new Error("The parameter 'cityProvinces_Exclude' cannot be null.");
        else if (cityProvinces_Exclude !== undefined)
            url_ += "CityProvinces.Exclude=" + encodeURIComponent("" + cityProvinces_Exclude) + "&";
        if (cityProvinces_Ids === null)
            throw new Error("The parameter 'cityProvinces_Ids' cannot be null.");
        else if (cityProvinces_Ids !== undefined)
            cityProvinces_Ids && cityProvinces_Ids.forEach(item => { url_ += "CityProvinces.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (khanDistricts_Exclude === null)
            throw new Error("The parameter 'khanDistricts_Exclude' cannot be null.");
        else if (khanDistricts_Exclude !== undefined)
            url_ += "KhanDistricts.Exclude=" + encodeURIComponent("" + khanDistricts_Exclude) + "&";
        if (khanDistricts_Ids === null)
            throw new Error("The parameter 'khanDistricts_Ids' cannot be null.");
        else if (khanDistricts_Ids !== undefined)
            khanDistricts_Ids && khanDistricts_Ids.forEach(item => { url_ += "KhanDistricts.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (sangkatCommunes_Exclude === null)
            throw new Error("The parameter 'sangkatCommunes_Exclude' cannot be null.");
        else if (sangkatCommunes_Exclude !== undefined)
            url_ += "SangkatCommunes.Exclude=" + encodeURIComponent("" + sangkatCommunes_Exclude) + "&";
        if (sangkatCommunes_Ids === null)
            throw new Error("The parameter 'sangkatCommunes_Ids' cannot be null.");
        else if (sangkatCommunes_Ids !== undefined)
            sangkatCommunes_Ids && sangkatCommunes_Ids.forEach(item => { url_ += "SangkatCommunes.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (creators_Exclude === null)
            throw new Error("The parameter 'creators_Exclude' cannot be null.");
        else if (creators_Exclude !== undefined)
            url_ += "Creators.Exclude=" + encodeURIComponent("" + creators_Exclude) + "&";
        if (creators_Ids === null)
            throw new Error("The parameter 'creators_Ids' cannot be null.");
        else if (creators_Ids !== undefined)
            creators_Ids && creators_Ids.forEach(item => { url_ += "Creators.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (modifiers_Exclude === null)
            throw new Error("The parameter 'modifiers_Exclude' cannot be null.");
        else if (modifiers_Exclude !== undefined)
            url_ += "Modifiers.Exclude=" + encodeURIComponent("" + modifiers_Exclude) + "&";
        if (modifiers_Ids === null)
            throw new Error("The parameter 'modifiers_Ids' cannot be null.");
        else if (modifiers_Ids !== undefined)
            modifiers_Ids && modifiers_Ids.forEach(item => { url_ += "Modifiers.Ids=" + encodeURIComponent("" + item) + "&"; });
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortMode === null)
            throw new Error("The parameter 'sortMode' cannot be null.");
        else if (sortMode !== undefined)
            url_ += "SortMode=" + encodeURIComponent("" + sortMode) + "&";
        if (usePagination === null)
            throw new Error("The parameter 'usePagination' cannot be null.");
        else if (usePagination !== undefined)
            url_ += "UsePagination=" + encodeURIComponent("" + usePagination) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VillageListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VillageListDtoPagedResultDto>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<VillageListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VillageListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    exportExcel(body: ExportExcelVillageInputDto | undefined): Observable<ExportFileOutput> {
        let url_ = this.baseUrl + "/api/services/app/Village/ExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExportFileOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExportFileOutput>;
        }));
    }

    protected processExportExcel(response: HttpResponseBase): Observable<ExportFileOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    exportExcelTemplate(): Observable<ExportFileOutput> {
        let url_ = this.baseUrl + "/api/services/app/Village/ExportExcelTemplate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExportFileOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExportFileOutput>;
        }));
    }

    protected processExportExcelTemplate(response: HttpResponseBase): Observable<ExportFileOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    importExcel(body: FileTokenInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Village/ImportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportExcel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: CreateUpdateVillageInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Village/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export enum AccountType {
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
    _15 = 15,
    _16 = 16,
    _20 = 20,
    _21 = 21,
    _22 = 22,
    _23 = 23,
    _30 = 30,
    _40 = 40,
    _41 = 41,
    _50 = 50,
    _51 = 51,
    _52 = 52,
}

export class AccountTypeFilterInputDto implements IAccountTypeFilterInputDto {
    exclude: boolean;
    ids: AccountType[] | undefined;

    constructor(data?: IAccountTypeFilterInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exclude = _data["exclude"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
        }
    }

    static fromJS(data: any): AccountTypeFilterInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountTypeFilterInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exclude"] = this.exclude;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }

    clone(): AccountTypeFilterInputDto {
        const json = this.toJSON();
        let result = new AccountTypeFilterInputDto();
        result.init(json);
        return result;
    }
}

export interface IAccountTypeFilterInputDto {
    exclude: boolean;
    ids: AccountType[] | undefined;
}

export class AccountTypeNameValueDto implements IAccountTypeNameValueDto {
    name: string | undefined;
    value: AccountType;

    constructor(data?: IAccountTypeNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): AccountTypeNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountTypeNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }

    clone(): AccountTypeNameValueDto {
        const json = this.toJSON();
        let result = new AccountTypeNameValueDto();
        result.init(json);
        return result;
    }
}

export interface IAccountTypeNameValueDto {
    name: string | undefined;
    value: AccountType;
}

export class AccountTypeNameValueDtoListResultDto implements IAccountTypeNameValueDtoListResultDto {
    items: AccountTypeNameValueDto[] | undefined;

    constructor(data?: IAccountTypeNameValueDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AccountTypeNameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountTypeNameValueDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountTypeNameValueDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): AccountTypeNameValueDtoListResultDto {
        const json = this.toJSON();
        let result = new AccountTypeNameValueDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IAccountTypeNameValueDtoListResultDto {
    items: AccountTypeNameValueDto[] | undefined;
}

export enum AddressLevel {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class AdvanceSettingDto implements IAdvanceSettingDto {
    multiBranchesEnable: boolean;
    multiCurrencyEnable: boolean;
    lineDiscountEnable: boolean;
    totalDiscountEnable: boolean;
    customAccountCodeEnable: boolean;
    classEnable: boolean;

    constructor(data?: IAdvanceSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.multiBranchesEnable = _data["multiBranchesEnable"];
            this.multiCurrencyEnable = _data["multiCurrencyEnable"];
            this.lineDiscountEnable = _data["lineDiscountEnable"];
            this.totalDiscountEnable = _data["totalDiscountEnable"];
            this.customAccountCodeEnable = _data["customAccountCodeEnable"];
            this.classEnable = _data["classEnable"];
        }
    }

    static fromJS(data: any): AdvanceSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdvanceSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["multiBranchesEnable"] = this.multiBranchesEnable;
        data["multiCurrencyEnable"] = this.multiCurrencyEnable;
        data["lineDiscountEnable"] = this.lineDiscountEnable;
        data["totalDiscountEnable"] = this.totalDiscountEnable;
        data["customAccountCodeEnable"] = this.customAccountCodeEnable;
        data["classEnable"] = this.classEnable;
        return data;
    }

    clone(): AdvanceSettingDto {
        const json = this.toJSON();
        let result = new AdvanceSettingDto();
        result.init(json);
        return result;
    }
}

export interface IAdvanceSettingDto {
    multiBranchesEnable: boolean;
    multiCurrencyEnable: boolean;
    lineDiscountEnable: boolean;
    totalDiscountEnable: boolean;
    customAccountCodeEnable: boolean;
    classEnable: boolean;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)[key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = (<any>this.features)[key];
            }
        }
        return data;
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    displayName: string | undefined;
    icon: string | undefined;
    isEnabled: boolean;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.icon = _data["icon"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data;
    }

    clone(): ApplicationLanguageEditDto {
        const json = this.toJSON();
        let result = new ApplicationLanguageEditDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    displayName: string | undefined;
    icon: string | undefined;
    isEnabled: boolean;
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.icon = _data["icon"];
            this.isDisabled = _data["isDisabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        return data;
    }

    clone(): ApplicationLanguageListDto {
        const json = this.toJSON();
        let result = new ApplicationLanguageListDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationLanguageListDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean;
}

export class AuditLogListDto implements IAuditLogListDto {
    id: number;
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment;
    executionDuration: number;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    success: boolean;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.impersonatorTenantId = _data["impersonatorTenantId"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.serviceName = _data["serviceName"];
            this.methodName = _data["methodName"];
            this.parameters = _data["parameters"];
            this.executionTime = _data["executionTime"] ? moment(_data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = _data["executionDuration"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.exception = _data["exception"];
            this.customData = _data["customData"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["success"] = this.success;
        return data;
    }

    clone(): AuditLogListDto {
        const json = this.toJSON();
        let result = new AuditLogListDto();
        result.init(json);
        return result;
    }
}

export interface IAuditLogListDto {
    id: number;
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment;
    executionDuration: number;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    success: boolean;
}

export class AuditLogListDtoPagedResultDto implements IAuditLogListDtoPagedResultDto {
    items: AuditLogListDto[] | undefined;
    totalCount: number;

    constructor(data?: IAuditLogListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AuditLogListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AuditLogListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): AuditLogListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AuditLogListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAuditLogListDtoPagedResultDto {
    items: AuditLogListDto[] | undefined;
    totalCount: number;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
    captchaResponse: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
    captchaResponse: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data;
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
}

export class BranchDetailDto implements IBranchDetailDto {
    id: string;
    firstId: string | undefined;
    nextId: string | undefined;
    previousId: string | undefined;
    lastId: string | undefined;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    isDefault: boolean;
    no: number;
    businessId: string | undefined;
    phoneNumber: string | undefined;
    email: string | undefined;
    website: string | undefined;
    taxRegistrationNumber: string | undefined;
    billingAddress: ContactAddressDto;
    sameAsBillingAddress: boolean;
    shippingAddress: ContactAddressDto;

    constructor(data?: IBranchDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstId = _data["firstId"];
            this.nextId = _data["nextId"];
            this.previousId = _data["previousId"];
            this.lastId = _data["lastId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModifierUserName = _data["lastModifierUserName"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isDefault = _data["isDefault"];
            this.no = _data["no"];
            this.businessId = _data["businessId"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.website = _data["website"];
            this.taxRegistrationNumber = _data["taxRegistrationNumber"];
            this.billingAddress = _data["billingAddress"] ? ContactAddressDto.fromJS(_data["billingAddress"]) : <any>undefined;
            this.sameAsBillingAddress = _data["sameAsBillingAddress"];
            this.shippingAddress = _data["shippingAddress"] ? ContactAddressDto.fromJS(_data["shippingAddress"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BranchDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranchDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstId"] = this.firstId;
        data["nextId"] = this.nextId;
        data["previousId"] = this.previousId;
        data["lastId"] = this.lastId;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModifierUserName"] = this.lastModifierUserName;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        data["no"] = this.no;
        data["businessId"] = this.businessId;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["website"] = this.website;
        data["taxRegistrationNumber"] = this.taxRegistrationNumber;
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : <any>undefined;
        data["sameAsBillingAddress"] = this.sameAsBillingAddress;
        data["shippingAddress"] = this.shippingAddress ? this.shippingAddress.toJSON() : <any>undefined;
        return data;
    }

    clone(): BranchDetailDto {
        const json = this.toJSON();
        let result = new BranchDetailDto();
        result.init(json);
        return result;
    }
}

export interface IBranchDetailDto {
    id: string;
    firstId: string | undefined;
    nextId: string | undefined;
    previousId: string | undefined;
    lastId: string | undefined;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    isDefault: boolean;
    no: number;
    businessId: string | undefined;
    phoneNumber: string | undefined;
    email: string | undefined;
    website: string | undefined;
    taxRegistrationNumber: string | undefined;
    billingAddress: ContactAddressDto;
    sameAsBillingAddress: boolean;
    shippingAddress: ContactAddressDto;
}

export class BranchListDto implements IBranchListDto {
    id: string;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    isDefault: boolean;
    no: number;
    businessId: string | undefined;
    phoneNumber: string | undefined;
    email: string | undefined;
    website: string | undefined;
    taxRegistrationNumber: string | undefined;

    constructor(data?: IBranchListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModifierUserName = _data["lastModifierUserName"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isDefault = _data["isDefault"];
            this.no = _data["no"];
            this.businessId = _data["businessId"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.website = _data["website"];
            this.taxRegistrationNumber = _data["taxRegistrationNumber"];
        }
    }

    static fromJS(data: any): BranchListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranchListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModifierUserName"] = this.lastModifierUserName;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        data["no"] = this.no;
        data["businessId"] = this.businessId;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["website"] = this.website;
        data["taxRegistrationNumber"] = this.taxRegistrationNumber;
        return data;
    }

    clone(): BranchListDto {
        const json = this.toJSON();
        let result = new BranchListDto();
        result.init(json);
        return result;
    }
}

export interface IBranchListDto {
    id: string;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    isDefault: boolean;
    no: number;
    businessId: string | undefined;
    phoneNumber: string | undefined;
    email: string | undefined;
    website: string | undefined;
    taxRegistrationNumber: string | undefined;
}

export class BranchListDtoPagedResultDto implements IBranchListDtoPagedResultDto {
    items: BranchListDto[] | undefined;
    totalCount: number;

    constructor(data?: IBranchListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(BranchListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): BranchListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranchListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): BranchListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new BranchListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBranchListDtoPagedResultDto {
    items: BranchListDto[] | undefined;
    totalCount: number;
}

export enum CellFormat {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ChangePasswordInput {
        const json = this.toJSON();
        let result = new ChangePasswordInput();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data;
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data;
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ChartOfAccountDetailDto implements IChartOfAccountDetailDto {
    id: string;
    firstId: string | undefined;
    nextId: string | undefined;
    previousId: string | undefined;
    lastId: string | undefined;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    accountType: AccountType;
    subAccountType: SubAccountType;
    accountTypeName: string | undefined;
    subAccountTypeName: string | undefined;
    parentId: string | undefined;
    parentAccountName: string | undefined;

    constructor(data?: IChartOfAccountDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstId = _data["firstId"];
            this.nextId = _data["nextId"];
            this.previousId = _data["previousId"];
            this.lastId = _data["lastId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModifierUserName = _data["lastModifierUserName"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.cannotEdit = _data["cannotEdit"];
            this.cannotDelete = _data["cannotDelete"];
            this.no = _data["no"];
            this.code = _data["code"];
            this.accountType = _data["accountType"];
            this.subAccountType = _data["subAccountType"];
            this.accountTypeName = _data["accountTypeName"];
            this.subAccountTypeName = _data["subAccountTypeName"];
            this.parentId = _data["parentId"];
            this.parentAccountName = _data["parentAccountName"];
        }
    }

    static fromJS(data: any): ChartOfAccountDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChartOfAccountDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstId"] = this.firstId;
        data["nextId"] = this.nextId;
        data["previousId"] = this.previousId;
        data["lastId"] = this.lastId;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModifierUserName"] = this.lastModifierUserName;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["cannotEdit"] = this.cannotEdit;
        data["cannotDelete"] = this.cannotDelete;
        data["no"] = this.no;
        data["code"] = this.code;
        data["accountType"] = this.accountType;
        data["subAccountType"] = this.subAccountType;
        data["accountTypeName"] = this.accountTypeName;
        data["subAccountTypeName"] = this.subAccountTypeName;
        data["parentId"] = this.parentId;
        data["parentAccountName"] = this.parentAccountName;
        return data;
    }

    clone(): ChartOfAccountDetailDto {
        const json = this.toJSON();
        let result = new ChartOfAccountDetailDto();
        result.init(json);
        return result;
    }
}

export interface IChartOfAccountDetailDto {
    id: string;
    firstId: string | undefined;
    nextId: string | undefined;
    previousId: string | undefined;
    lastId: string | undefined;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    accountType: AccountType;
    subAccountType: SubAccountType;
    accountTypeName: string | undefined;
    subAccountTypeName: string | undefined;
    parentId: string | undefined;
    parentAccountName: string | undefined;
}

export class ChartOfAccountListDto implements IChartOfAccountListDto {
    id: string;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    accountType: string | undefined;
    subAccountType: string | undefined;
    parentId: string | undefined;
    parentAccountName: string | undefined;

    constructor(data?: IChartOfAccountListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModifierUserName = _data["lastModifierUserName"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.cannotEdit = _data["cannotEdit"];
            this.cannotDelete = _data["cannotDelete"];
            this.no = _data["no"];
            this.code = _data["code"];
            this.accountType = _data["accountType"];
            this.subAccountType = _data["subAccountType"];
            this.parentId = _data["parentId"];
            this.parentAccountName = _data["parentAccountName"];
        }
    }

    static fromJS(data: any): ChartOfAccountListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChartOfAccountListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModifierUserName"] = this.lastModifierUserName;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["cannotEdit"] = this.cannotEdit;
        data["cannotDelete"] = this.cannotDelete;
        data["no"] = this.no;
        data["code"] = this.code;
        data["accountType"] = this.accountType;
        data["subAccountType"] = this.subAccountType;
        data["parentId"] = this.parentId;
        data["parentAccountName"] = this.parentAccountName;
        return data;
    }

    clone(): ChartOfAccountListDto {
        const json = this.toJSON();
        let result = new ChartOfAccountListDto();
        result.init(json);
        return result;
    }
}

export interface IChartOfAccountListDto {
    id: string;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    accountType: string | undefined;
    subAccountType: string | undefined;
    parentId: string | undefined;
    parentAccountName: string | undefined;
}

export class ChartOfAccountListDtoPagedResultDto implements IChartOfAccountListDtoPagedResultDto {
    items: ChartOfAccountListDto[] | undefined;
    totalCount: number;

    constructor(data?: IChartOfAccountListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ChartOfAccountListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ChartOfAccountListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChartOfAccountListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ChartOfAccountListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ChartOfAccountListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IChartOfAccountListDtoPagedResultDto {
    items: ChartOfAccountListDto[] | undefined;
    totalCount: number;
}

export class CityProvinceDetailDto implements ICityProvinceDetailDto {
    id: string;
    firstId: string | undefined;
    nextId: string | undefined;
    previousId: string | undefined;
    lastId: string | undefined;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    iso: string | undefined;
    countryId: string | undefined;
    countryName: string | undefined;

    constructor(data?: ICityProvinceDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstId = _data["firstId"];
            this.nextId = _data["nextId"];
            this.previousId = _data["previousId"];
            this.lastId = _data["lastId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModifierUserName = _data["lastModifierUserName"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.cannotEdit = _data["cannotEdit"];
            this.cannotDelete = _data["cannotDelete"];
            this.no = _data["no"];
            this.code = _data["code"];
            this.iso = _data["iso"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): CityProvinceDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityProvinceDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstId"] = this.firstId;
        data["nextId"] = this.nextId;
        data["previousId"] = this.previousId;
        data["lastId"] = this.lastId;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModifierUserName"] = this.lastModifierUserName;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["cannotEdit"] = this.cannotEdit;
        data["cannotDelete"] = this.cannotDelete;
        data["no"] = this.no;
        data["code"] = this.code;
        data["iso"] = this.iso;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        return data;
    }

    clone(): CityProvinceDetailDto {
        const json = this.toJSON();
        let result = new CityProvinceDetailDto();
        result.init(json);
        return result;
    }
}

export interface ICityProvinceDetailDto {
    id: string;
    firstId: string | undefined;
    nextId: string | undefined;
    previousId: string | undefined;
    lastId: string | undefined;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    iso: string | undefined;
    countryId: string | undefined;
    countryName: string | undefined;
}

export class CityProvinceListDto implements ICityProvinceListDto {
    id: string;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    iso: string | undefined;
    countryName: string | undefined;

    constructor(data?: ICityProvinceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModifierUserName = _data["lastModifierUserName"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.cannotEdit = _data["cannotEdit"];
            this.cannotDelete = _data["cannotDelete"];
            this.no = _data["no"];
            this.code = _data["code"];
            this.iso = _data["iso"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): CityProvinceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityProvinceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModifierUserName"] = this.lastModifierUserName;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["cannotEdit"] = this.cannotEdit;
        data["cannotDelete"] = this.cannotDelete;
        data["no"] = this.no;
        data["code"] = this.code;
        data["iso"] = this.iso;
        data["countryName"] = this.countryName;
        return data;
    }

    clone(): CityProvinceListDto {
        const json = this.toJSON();
        let result = new CityProvinceListDto();
        result.init(json);
        return result;
    }
}

export interface ICityProvinceListDto {
    id: string;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    iso: string | undefined;
    countryName: string | undefined;
}

export class CityProvinceListDtoPagedResultDto implements ICityProvinceListDtoPagedResultDto {
    items: CityProvinceListDto[] | undefined;
    totalCount: number;

    constructor(data?: ICityProvinceListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CityProvinceListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CityProvinceListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityProvinceListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): CityProvinceListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CityProvinceListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICityProvinceListDtoPagedResultDto {
    items: CityProvinceListDto[] | undefined;
    totalCount: number;
}

export class ColumnOutput implements IColumnOutput {
    columnName: string | undefined;
    columnTitle: string | undefined;
    index: number;
    visible: boolean;
    width: number;
    columnType: ColumnType;
    cellFormat: CellFormat;
    roundingDigits: number;
    showCrossForFalse: boolean;
    isRequired: boolean;

    constructor(data?: IColumnOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.columnName = _data["columnName"];
            this.columnTitle = _data["columnTitle"];
            this.index = _data["index"];
            this.visible = _data["visible"];
            this.width = _data["width"];
            this.columnType = _data["columnType"];
            this.cellFormat = _data["cellFormat"];
            this.roundingDigits = _data["roundingDigits"];
            this.showCrossForFalse = _data["showCrossForFalse"];
            this.isRequired = _data["isRequired"];
        }
    }

    static fromJS(data: any): ColumnOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ColumnOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["columnName"] = this.columnName;
        data["columnTitle"] = this.columnTitle;
        data["index"] = this.index;
        data["visible"] = this.visible;
        data["width"] = this.width;
        data["columnType"] = this.columnType;
        data["cellFormat"] = this.cellFormat;
        data["roundingDigits"] = this.roundingDigits;
        data["showCrossForFalse"] = this.showCrossForFalse;
        data["isRequired"] = this.isRequired;
        return data;
    }

    clone(): ColumnOutput {
        const json = this.toJSON();
        let result = new ColumnOutput();
        result.init(json);
        return result;
    }
}

export interface IColumnOutput {
    columnName: string | undefined;
    columnTitle: string | undefined;
    index: number;
    visible: boolean;
    width: number;
    columnType: ColumnType;
    cellFormat: CellFormat;
    roundingDigits: number;
    showCrossForFalse: boolean;
    isRequired: boolean;
}

export enum ColumnType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
}

export class ComboboxItemDto implements IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.displayText = _data["displayText"];
            this.isSelected = _data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data;
    }

    clone(): ComboboxItemDto {
        const json = this.toJSON();
        let result = new ComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;
}

export class CompanyAccountSettingDto implements ICompanyAccountSettingDto {
    id: number | undefined;
    defaultAPAccountId: string | undefined;
    defaultAPAccountName: string | undefined;
    defaultARAccountId: string | undefined;
    defaultARAccountName: string | undefined;
    defaultPurchaseDiscountAccountId: string | undefined;
    defaultPurchaseDiscountAccountName: string | undefined;
    defaultSaleDiscountAccountId: string | undefined;
    defaultSaleDiscountAccountName: string | undefined;
    defaultInventoryPurchaseAccountId: string | undefined;
    defaultInventoryPurchaseAccountName: string | undefined;
    defaultBillPaymentAccountId: string | undefined;
    defaultBillPaymentAccountName: string | undefined;
    defaultReceivePaymentAccountId: string | undefined;
    defaultReceivePaymentAccountName: string | undefined;
    defaultRetainEarningAccountId: string | undefined;
    defaultRetainEarningAccountName: string | undefined;
    defaultExchangeLossGainAccountId: string | undefined;
    defaultExchangeLossGainAccountName: string | undefined;
    defaultItemReceiptAccountId: string | undefined;
    defaultItemReceiptAccountName: string | undefined;
    defaultItemIssueAccountId: string | undefined;
    defaultItemIssueAccountName: string | undefined;
    defaultItemAdjustmentAccountId: string | undefined;
    defaultItemAdjustmentAccountName: string | undefined;
    defaultItemTransferAccountId: string | undefined;
    defaultItemTransferAccountName: string | undefined;
    defaultItemProductionAccountId: string | undefined;
    defaultItemProductionAccountName: string | undefined;
    defaultItemExchangeAccountId: string | undefined;
    defaultItemExchangeAccountName: string | undefined;
    defaultCashTransferAccountId: string | undefined;
    defaultCashTransferAccountName: string | undefined;
    defaultCashExchangeAccountId: string | undefined;
    defaultCashExchangeAccountName: string | undefined;

    constructor(data?: ICompanyAccountSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.defaultAPAccountId = _data["defaultAPAccountId"];
            this.defaultAPAccountName = _data["defaultAPAccountName"];
            this.defaultARAccountId = _data["defaultARAccountId"];
            this.defaultARAccountName = _data["defaultARAccountName"];
            this.defaultPurchaseDiscountAccountId = _data["defaultPurchaseDiscountAccountId"];
            this.defaultPurchaseDiscountAccountName = _data["defaultPurchaseDiscountAccountName"];
            this.defaultSaleDiscountAccountId = _data["defaultSaleDiscountAccountId"];
            this.defaultSaleDiscountAccountName = _data["defaultSaleDiscountAccountName"];
            this.defaultInventoryPurchaseAccountId = _data["defaultInventoryPurchaseAccountId"];
            this.defaultInventoryPurchaseAccountName = _data["defaultInventoryPurchaseAccountName"];
            this.defaultBillPaymentAccountId = _data["defaultBillPaymentAccountId"];
            this.defaultBillPaymentAccountName = _data["defaultBillPaymentAccountName"];
            this.defaultReceivePaymentAccountId = _data["defaultReceivePaymentAccountId"];
            this.defaultReceivePaymentAccountName = _data["defaultReceivePaymentAccountName"];
            this.defaultRetainEarningAccountId = _data["defaultRetainEarningAccountId"];
            this.defaultRetainEarningAccountName = _data["defaultRetainEarningAccountName"];
            this.defaultExchangeLossGainAccountId = _data["defaultExchangeLossGainAccountId"];
            this.defaultExchangeLossGainAccountName = _data["defaultExchangeLossGainAccountName"];
            this.defaultItemReceiptAccountId = _data["defaultItemReceiptAccountId"];
            this.defaultItemReceiptAccountName = _data["defaultItemReceiptAccountName"];
            this.defaultItemIssueAccountId = _data["defaultItemIssueAccountId"];
            this.defaultItemIssueAccountName = _data["defaultItemIssueAccountName"];
            this.defaultItemAdjustmentAccountId = _data["defaultItemAdjustmentAccountId"];
            this.defaultItemAdjustmentAccountName = _data["defaultItemAdjustmentAccountName"];
            this.defaultItemTransferAccountId = _data["defaultItemTransferAccountId"];
            this.defaultItemTransferAccountName = _data["defaultItemTransferAccountName"];
            this.defaultItemProductionAccountId = _data["defaultItemProductionAccountId"];
            this.defaultItemProductionAccountName = _data["defaultItemProductionAccountName"];
            this.defaultItemExchangeAccountId = _data["defaultItemExchangeAccountId"];
            this.defaultItemExchangeAccountName = _data["defaultItemExchangeAccountName"];
            this.defaultCashTransferAccountId = _data["defaultCashTransferAccountId"];
            this.defaultCashTransferAccountName = _data["defaultCashTransferAccountName"];
            this.defaultCashExchangeAccountId = _data["defaultCashExchangeAccountId"];
            this.defaultCashExchangeAccountName = _data["defaultCashExchangeAccountName"];
        }
    }

    static fromJS(data: any): CompanyAccountSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyAccountSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["defaultAPAccountId"] = this.defaultAPAccountId;
        data["defaultAPAccountName"] = this.defaultAPAccountName;
        data["defaultARAccountId"] = this.defaultARAccountId;
        data["defaultARAccountName"] = this.defaultARAccountName;
        data["defaultPurchaseDiscountAccountId"] = this.defaultPurchaseDiscountAccountId;
        data["defaultPurchaseDiscountAccountName"] = this.defaultPurchaseDiscountAccountName;
        data["defaultSaleDiscountAccountId"] = this.defaultSaleDiscountAccountId;
        data["defaultSaleDiscountAccountName"] = this.defaultSaleDiscountAccountName;
        data["defaultInventoryPurchaseAccountId"] = this.defaultInventoryPurchaseAccountId;
        data["defaultInventoryPurchaseAccountName"] = this.defaultInventoryPurchaseAccountName;
        data["defaultBillPaymentAccountId"] = this.defaultBillPaymentAccountId;
        data["defaultBillPaymentAccountName"] = this.defaultBillPaymentAccountName;
        data["defaultReceivePaymentAccountId"] = this.defaultReceivePaymentAccountId;
        data["defaultReceivePaymentAccountName"] = this.defaultReceivePaymentAccountName;
        data["defaultRetainEarningAccountId"] = this.defaultRetainEarningAccountId;
        data["defaultRetainEarningAccountName"] = this.defaultRetainEarningAccountName;
        data["defaultExchangeLossGainAccountId"] = this.defaultExchangeLossGainAccountId;
        data["defaultExchangeLossGainAccountName"] = this.defaultExchangeLossGainAccountName;
        data["defaultItemReceiptAccountId"] = this.defaultItemReceiptAccountId;
        data["defaultItemReceiptAccountName"] = this.defaultItemReceiptAccountName;
        data["defaultItemIssueAccountId"] = this.defaultItemIssueAccountId;
        data["defaultItemIssueAccountName"] = this.defaultItemIssueAccountName;
        data["defaultItemAdjustmentAccountId"] = this.defaultItemAdjustmentAccountId;
        data["defaultItemAdjustmentAccountName"] = this.defaultItemAdjustmentAccountName;
        data["defaultItemTransferAccountId"] = this.defaultItemTransferAccountId;
        data["defaultItemTransferAccountName"] = this.defaultItemTransferAccountName;
        data["defaultItemProductionAccountId"] = this.defaultItemProductionAccountId;
        data["defaultItemProductionAccountName"] = this.defaultItemProductionAccountName;
        data["defaultItemExchangeAccountId"] = this.defaultItemExchangeAccountId;
        data["defaultItemExchangeAccountName"] = this.defaultItemExchangeAccountName;
        data["defaultCashTransferAccountId"] = this.defaultCashTransferAccountId;
        data["defaultCashTransferAccountName"] = this.defaultCashTransferAccountName;
        data["defaultCashExchangeAccountId"] = this.defaultCashExchangeAccountId;
        data["defaultCashExchangeAccountName"] = this.defaultCashExchangeAccountName;
        return data;
    }

    clone(): CompanyAccountSettingDto {
        const json = this.toJSON();
        let result = new CompanyAccountSettingDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyAccountSettingDto {
    id: number | undefined;
    defaultAPAccountId: string | undefined;
    defaultAPAccountName: string | undefined;
    defaultARAccountId: string | undefined;
    defaultARAccountName: string | undefined;
    defaultPurchaseDiscountAccountId: string | undefined;
    defaultPurchaseDiscountAccountName: string | undefined;
    defaultSaleDiscountAccountId: string | undefined;
    defaultSaleDiscountAccountName: string | undefined;
    defaultInventoryPurchaseAccountId: string | undefined;
    defaultInventoryPurchaseAccountName: string | undefined;
    defaultBillPaymentAccountId: string | undefined;
    defaultBillPaymentAccountName: string | undefined;
    defaultReceivePaymentAccountId: string | undefined;
    defaultReceivePaymentAccountName: string | undefined;
    defaultRetainEarningAccountId: string | undefined;
    defaultRetainEarningAccountName: string | undefined;
    defaultExchangeLossGainAccountId: string | undefined;
    defaultExchangeLossGainAccountName: string | undefined;
    defaultItemReceiptAccountId: string | undefined;
    defaultItemReceiptAccountName: string | undefined;
    defaultItemIssueAccountId: string | undefined;
    defaultItemIssueAccountName: string | undefined;
    defaultItemAdjustmentAccountId: string | undefined;
    defaultItemAdjustmentAccountName: string | undefined;
    defaultItemTransferAccountId: string | undefined;
    defaultItemTransferAccountName: string | undefined;
    defaultItemProductionAccountId: string | undefined;
    defaultItemProductionAccountName: string | undefined;
    defaultItemExchangeAccountId: string | undefined;
    defaultItemExchangeAccountName: string | undefined;
    defaultCashTransferAccountId: string | undefined;
    defaultCashTransferAccountName: string | undefined;
    defaultCashExchangeAccountId: string | undefined;
    defaultCashExchangeAccountName: string | undefined;
}

export class CompanyAdvanceSettingDto implements ICompanyAdvanceSettingDto {
    id: number | undefined;
    multiBranchesEnable: boolean;
    multiCurrencyEnable: boolean;
    lineDiscountEnable: boolean;
    totalDiscountEnable: boolean;
    customAccountCodeEnable: boolean;
    classEnable: boolean;

    constructor(data?: ICompanyAdvanceSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.multiBranchesEnable = _data["multiBranchesEnable"];
            this.multiCurrencyEnable = _data["multiCurrencyEnable"];
            this.lineDiscountEnable = _data["lineDiscountEnable"];
            this.totalDiscountEnable = _data["totalDiscountEnable"];
            this.customAccountCodeEnable = _data["customAccountCodeEnable"];
            this.classEnable = _data["classEnable"];
        }
    }

    static fromJS(data: any): CompanyAdvanceSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyAdvanceSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["multiBranchesEnable"] = this.multiBranchesEnable;
        data["multiCurrencyEnable"] = this.multiCurrencyEnable;
        data["lineDiscountEnable"] = this.lineDiscountEnable;
        data["totalDiscountEnable"] = this.totalDiscountEnable;
        data["customAccountCodeEnable"] = this.customAccountCodeEnable;
        data["classEnable"] = this.classEnable;
        return data;
    }

    clone(): CompanyAdvanceSettingDto {
        const json = this.toJSON();
        let result = new CompanyAdvanceSettingDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyAdvanceSettingDto {
    id: number | undefined;
    multiBranchesEnable: boolean;
    multiCurrencyEnable: boolean;
    lineDiscountEnable: boolean;
    totalDiscountEnable: boolean;
    customAccountCodeEnable: boolean;
    classEnable: boolean;
}

export class CompanyGeneralSettingDto implements ICompanyGeneralSettingDto {
    id: number | undefined;
    countryId: string | undefined;
    countryName: string | undefined;
    defaultTimeZone: string | undefined;
    currencyId: number | undefined;
    currencyCode: string | undefined;
    businessStartDate: moment.Moment | undefined;
    roundTotalDigits: number;
    roundCostDigits: number;
    contactAddressLevel: AddressLevel;

    constructor(data?: ICompanyGeneralSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.defaultTimeZone = _data["defaultTimeZone"];
            this.currencyId = _data["currencyId"];
            this.currencyCode = _data["currencyCode"];
            this.businessStartDate = _data["businessStartDate"] ? moment(_data["businessStartDate"].toString()) : <any>undefined;
            this.roundTotalDigits = _data["roundTotalDigits"];
            this.roundCostDigits = _data["roundCostDigits"];
            this.contactAddressLevel = _data["contactAddressLevel"];
        }
    }

    static fromJS(data: any): CompanyGeneralSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyGeneralSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["defaultTimeZone"] = this.defaultTimeZone;
        data["currencyId"] = this.currencyId;
        data["currencyCode"] = this.currencyCode;
        data["businessStartDate"] = this.businessStartDate ? this.businessStartDate.toISOString() : <any>undefined;
        data["roundTotalDigits"] = this.roundTotalDigits;
        data["roundCostDigits"] = this.roundCostDigits;
        data["contactAddressLevel"] = this.contactAddressLevel;
        return data;
    }

    clone(): CompanyGeneralSettingDto {
        const json = this.toJSON();
        let result = new CompanyGeneralSettingDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyGeneralSettingDto {
    id: number | undefined;
    countryId: string | undefined;
    countryName: string | undefined;
    defaultTimeZone: string | undefined;
    currencyId: number | undefined;
    currencyCode: string | undefined;
    businessStartDate: moment.Moment | undefined;
    roundTotalDigits: number;
    roundCostDigits: number;
    contactAddressLevel: AddressLevel;
}

export class CompanySettingDto implements ICompanySettingDto {
    companyLogo: UpdateLogoInput;
    branch: BranchDetailDto;
    generalSetting: CompanyGeneralSettingDto;
    advanceSetting: CompanyAdvanceSettingDto;
    accountSetting: CompanyAccountSettingDto;
    transactionNoSettings: TransactionNoSettingDto[] | undefined;

    constructor(data?: ICompanySettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyLogo = _data["companyLogo"] ? UpdateLogoInput.fromJS(_data["companyLogo"]) : <any>undefined;
            this.branch = _data["branch"] ? BranchDetailDto.fromJS(_data["branch"]) : <any>undefined;
            this.generalSetting = _data["generalSetting"] ? CompanyGeneralSettingDto.fromJS(_data["generalSetting"]) : <any>undefined;
            this.advanceSetting = _data["advanceSetting"] ? CompanyAdvanceSettingDto.fromJS(_data["advanceSetting"]) : <any>undefined;
            this.accountSetting = _data["accountSetting"] ? CompanyAccountSettingDto.fromJS(_data["accountSetting"]) : <any>undefined;
            if (Array.isArray(_data["transactionNoSettings"])) {
                this.transactionNoSettings = [] as any;
                for (let item of _data["transactionNoSettings"])
                    this.transactionNoSettings.push(TransactionNoSettingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompanySettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanySettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyLogo"] = this.companyLogo ? this.companyLogo.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["generalSetting"] = this.generalSetting ? this.generalSetting.toJSON() : <any>undefined;
        data["advanceSetting"] = this.advanceSetting ? this.advanceSetting.toJSON() : <any>undefined;
        data["accountSetting"] = this.accountSetting ? this.accountSetting.toJSON() : <any>undefined;
        if (Array.isArray(this.transactionNoSettings)) {
            data["transactionNoSettings"] = [];
            for (let item of this.transactionNoSettings)
                data["transactionNoSettings"].push(item.toJSON());
        }
        return data;
    }

    clone(): CompanySettingDto {
        const json = this.toJSON();
        let result = new CompanySettingDto();
        result.init(json);
        return result;
    }
}

export interface ICompanySettingDto {
    companyLogo: UpdateLogoInput;
    branch: BranchDetailDto;
    generalSetting: CompanyGeneralSettingDto;
    advanceSetting: CompanyAdvanceSettingDto;
    accountSetting: CompanyAccountSettingDto;
    transactionNoSettings: TransactionNoSettingDto[] | undefined;
}

export class ContactAddressDto implements IContactAddressDto {
    id: string;
    countryId: string | undefined;
    countryName: string | undefined;
    cityProvinceId: string | undefined;
    cityProvinceName: string | undefined;
    khanDistrictId: string | undefined;
    khanDistrictName: string | undefined;
    sangkatCommuneId: string | undefined;
    sangkatCommuneName: string | undefined;
    villageId: string | undefined;
    villageName: string | undefined;
    locationId: string | undefined;
    locationName: string | undefined;
    postalCode: string | undefined;
    street: string | undefined;
    houseNo: string | undefined;

    constructor(data?: IContactAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.cityProvinceId = _data["cityProvinceId"];
            this.cityProvinceName = _data["cityProvinceName"];
            this.khanDistrictId = _data["khanDistrictId"];
            this.khanDistrictName = _data["khanDistrictName"];
            this.sangkatCommuneId = _data["sangkatCommuneId"];
            this.sangkatCommuneName = _data["sangkatCommuneName"];
            this.villageId = _data["villageId"];
            this.villageName = _data["villageName"];
            this.locationId = _data["locationId"];
            this.locationName = _data["locationName"];
            this.postalCode = _data["postalCode"];
            this.street = _data["street"];
            this.houseNo = _data["houseNo"];
        }
    }

    static fromJS(data: any): ContactAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["cityProvinceId"] = this.cityProvinceId;
        data["cityProvinceName"] = this.cityProvinceName;
        data["khanDistrictId"] = this.khanDistrictId;
        data["khanDistrictName"] = this.khanDistrictName;
        data["sangkatCommuneId"] = this.sangkatCommuneId;
        data["sangkatCommuneName"] = this.sangkatCommuneName;
        data["villageId"] = this.villageId;
        data["villageName"] = this.villageName;
        data["locationId"] = this.locationId;
        data["locationName"] = this.locationName;
        data["postalCode"] = this.postalCode;
        data["street"] = this.street;
        data["houseNo"] = this.houseNo;
        return data;
    }

    clone(): ContactAddressDto {
        const json = this.toJSON();
        let result = new ContactAddressDto();
        result.init(json);
        return result;
    }
}

export interface IContactAddressDto {
    id: string;
    countryId: string | undefined;
    countryName: string | undefined;
    cityProvinceId: string | undefined;
    cityProvinceName: string | undefined;
    khanDistrictId: string | undefined;
    khanDistrictName: string | undefined;
    sangkatCommuneId: string | undefined;
    sangkatCommuneName: string | undefined;
    villageId: string | undefined;
    villageName: string | undefined;
    locationId: string | undefined;
    locationName: string | undefined;
    postalCode: string | undefined;
    street: string | undefined;
    houseNo: string | undefined;
}

export class CountryDetailDto implements ICountryDetailDto {
    id: string;
    firstId: string | undefined;
    nextId: string | undefined;
    previousId: string | undefined;
    lastId: string | undefined;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    iso: string | undefined;
    isO2: string | undefined;
    phonePrefix: string | undefined;
    currencyId: number | undefined;
    currencyCode: string | undefined;

    constructor(data?: ICountryDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstId = _data["firstId"];
            this.nextId = _data["nextId"];
            this.previousId = _data["previousId"];
            this.lastId = _data["lastId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModifierUserName = _data["lastModifierUserName"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.cannotEdit = _data["cannotEdit"];
            this.cannotDelete = _data["cannotDelete"];
            this.no = _data["no"];
            this.code = _data["code"];
            this.iso = _data["iso"];
            this.isO2 = _data["isO2"];
            this.phonePrefix = _data["phonePrefix"];
            this.currencyId = _data["currencyId"];
            this.currencyCode = _data["currencyCode"];
        }
    }

    static fromJS(data: any): CountryDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstId"] = this.firstId;
        data["nextId"] = this.nextId;
        data["previousId"] = this.previousId;
        data["lastId"] = this.lastId;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModifierUserName"] = this.lastModifierUserName;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["cannotEdit"] = this.cannotEdit;
        data["cannotDelete"] = this.cannotDelete;
        data["no"] = this.no;
        data["code"] = this.code;
        data["iso"] = this.iso;
        data["isO2"] = this.isO2;
        data["phonePrefix"] = this.phonePrefix;
        data["currencyId"] = this.currencyId;
        data["currencyCode"] = this.currencyCode;
        return data;
    }

    clone(): CountryDetailDto {
        const json = this.toJSON();
        let result = new CountryDetailDto();
        result.init(json);
        return result;
    }
}

export interface ICountryDetailDto {
    id: string;
    firstId: string | undefined;
    nextId: string | undefined;
    previousId: string | undefined;
    lastId: string | undefined;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    iso: string | undefined;
    isO2: string | undefined;
    phonePrefix: string | undefined;
    currencyId: number | undefined;
    currencyCode: string | undefined;
}

export class CountryListDto implements ICountryListDto {
    id: string;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    iso: string | undefined;
    isO2: string | undefined;
    phonePrefix: string | undefined;
    currencyCode: string | undefined;

    constructor(data?: ICountryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModifierUserName = _data["lastModifierUserName"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.cannotEdit = _data["cannotEdit"];
            this.cannotDelete = _data["cannotDelete"];
            this.no = _data["no"];
            this.code = _data["code"];
            this.iso = _data["iso"];
            this.isO2 = _data["isO2"];
            this.phonePrefix = _data["phonePrefix"];
            this.currencyCode = _data["currencyCode"];
        }
    }

    static fromJS(data: any): CountryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModifierUserName"] = this.lastModifierUserName;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["cannotEdit"] = this.cannotEdit;
        data["cannotDelete"] = this.cannotDelete;
        data["no"] = this.no;
        data["code"] = this.code;
        data["iso"] = this.iso;
        data["isO2"] = this.isO2;
        data["phonePrefix"] = this.phonePrefix;
        data["currencyCode"] = this.currencyCode;
        return data;
    }

    clone(): CountryListDto {
        const json = this.toJSON();
        let result = new CountryListDto();
        result.init(json);
        return result;
    }
}

export interface ICountryListDto {
    id: string;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    iso: string | undefined;
    isO2: string | undefined;
    phonePrefix: string | undefined;
    currencyCode: string | undefined;
}

export class CountryListDtoPagedResultDto implements ICountryListDtoPagedResultDto {
    items: CountryListDto[] | undefined;
    totalCount: number;

    constructor(data?: ICountryListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CountryListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CountryListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): CountryListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CountryListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICountryListDtoPagedResultDto {
    items: CountryListDto[] | undefined;
    totalCount: number;
}

export class CreateOrUpdateEditionDto implements ICreateOrUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];

    constructor(data?: ICreateOrUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionEditDto.fromJS(_data["edition"]) : new EditionEditDto();
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateOrUpdateEditionDto {
        const json = this.toJSON();
        let result = new CreateOrUpdateEditionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"] ? ApplicationLanguageEditDto.fromJS(_data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateOrUpdateLanguageInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateLanguageInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data;
    }

    clone(): CreateOrganizationUnitInput {
        const json = this.toJSON();
        let result = new CreateOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;
    editionId: number | undefined;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
            this.editionId = _data["editionId"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["editionId"] = this.editionId;
        return data;
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;
    editionId: number | undefined;
}

export class CreateUpdateBranchInputDto implements ICreateUpdateBranchInputDto {
    id: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    businessId: string | undefined;
    phoneNumber: string | undefined;
    email: string | undefined;
    website: string | undefined;
    taxRegistrationNumber: string | undefined;
    billingAddress: ContactAddressDto;
    sameAsBillingAddress: boolean;
    shippingAddress: ContactAddressDto;

    constructor(data?: ICreateUpdateBranchInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.businessId = _data["businessId"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.website = _data["website"];
            this.taxRegistrationNumber = _data["taxRegistrationNumber"];
            this.billingAddress = _data["billingAddress"] ? ContactAddressDto.fromJS(_data["billingAddress"]) : <any>undefined;
            this.sameAsBillingAddress = _data["sameAsBillingAddress"];
            this.shippingAddress = _data["shippingAddress"] ? ContactAddressDto.fromJS(_data["shippingAddress"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateUpdateBranchInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateBranchInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["businessId"] = this.businessId;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["website"] = this.website;
        data["taxRegistrationNumber"] = this.taxRegistrationNumber;
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : <any>undefined;
        data["sameAsBillingAddress"] = this.sameAsBillingAddress;
        data["shippingAddress"] = this.shippingAddress ? this.shippingAddress.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateUpdateBranchInputDto {
        const json = this.toJSON();
        let result = new CreateUpdateBranchInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateBranchInputDto {
    id: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    businessId: string | undefined;
    phoneNumber: string | undefined;
    email: string | undefined;
    website: string | undefined;
    taxRegistrationNumber: string | undefined;
    billingAddress: ContactAddressDto;
    sameAsBillingAddress: boolean;
    shippingAddress: ContactAddressDto;
}

export class CreateUpdateChartOfAccountInputDto implements ICreateUpdateChartOfAccountInputDto {
    id: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    code: string | undefined;
    accountType: AccountType;
    subAccountType: SubAccountType;
    parentId: string | undefined;

    constructor(data?: ICreateUpdateChartOfAccountInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.code = _data["code"];
            this.accountType = _data["accountType"];
            this.subAccountType = _data["subAccountType"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): CreateUpdateChartOfAccountInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateChartOfAccountInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["code"] = this.code;
        data["accountType"] = this.accountType;
        data["subAccountType"] = this.subAccountType;
        data["parentId"] = this.parentId;
        return data;
    }

    clone(): CreateUpdateChartOfAccountInputDto {
        const json = this.toJSON();
        let result = new CreateUpdateChartOfAccountInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateChartOfAccountInputDto {
    id: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    code: string | undefined;
    accountType: AccountType;
    subAccountType: SubAccountType;
    parentId: string | undefined;
}

export class CreateUpdateCityProvinceInputDto implements ICreateUpdateCityProvinceInputDto {
    id: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    code: string | undefined;
    iso: string | undefined;
    countryId: string | undefined;

    constructor(data?: ICreateUpdateCityProvinceInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.code = _data["code"];
            this.iso = _data["iso"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): CreateUpdateCityProvinceInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateCityProvinceInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["code"] = this.code;
        data["iso"] = this.iso;
        data["countryId"] = this.countryId;
        return data;
    }

    clone(): CreateUpdateCityProvinceInputDto {
        const json = this.toJSON();
        let result = new CreateUpdateCityProvinceInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateCityProvinceInputDto {
    id: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    code: string | undefined;
    iso: string | undefined;
    countryId: string | undefined;
}

export class CreateUpdateCompanyAccountSettingInputDto implements ICreateUpdateCompanyAccountSettingInputDto {
    id: number | undefined;
    defaultAPAccountId: string | undefined;
    defaultARAccountId: string | undefined;
    defaultPurchaseDiscountAccountId: string | undefined;
    defaultSaleDiscountAccountId: string | undefined;
    defaultInventoryPurchaseAccountId: string | undefined;
    defaultBillPaymentAccountId: string | undefined;
    defaultReceivePaymentAccountId: string | undefined;
    defaultRetainEarningAccountId: string | undefined;
    defaultExchangeLossGainAccountId: string | undefined;
    defaultItemReceiptAccountId: string | undefined;
    defaultItemIssueAccountId: string | undefined;
    defaultItemAdjustmentAccountId: string | undefined;
    defaultItemTransferAccountId: string | undefined;
    defaultItemProductionAccountId: string | undefined;
    defaultItemExchangeAccountId: string | undefined;
    defaultCashTransferAccountId: string | undefined;
    defaultCashExchangeAccountId: string | undefined;

    constructor(data?: ICreateUpdateCompanyAccountSettingInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.defaultAPAccountId = _data["defaultAPAccountId"];
            this.defaultARAccountId = _data["defaultARAccountId"];
            this.defaultPurchaseDiscountAccountId = _data["defaultPurchaseDiscountAccountId"];
            this.defaultSaleDiscountAccountId = _data["defaultSaleDiscountAccountId"];
            this.defaultInventoryPurchaseAccountId = _data["defaultInventoryPurchaseAccountId"];
            this.defaultBillPaymentAccountId = _data["defaultBillPaymentAccountId"];
            this.defaultReceivePaymentAccountId = _data["defaultReceivePaymentAccountId"];
            this.defaultRetainEarningAccountId = _data["defaultRetainEarningAccountId"];
            this.defaultExchangeLossGainAccountId = _data["defaultExchangeLossGainAccountId"];
            this.defaultItemReceiptAccountId = _data["defaultItemReceiptAccountId"];
            this.defaultItemIssueAccountId = _data["defaultItemIssueAccountId"];
            this.defaultItemAdjustmentAccountId = _data["defaultItemAdjustmentAccountId"];
            this.defaultItemTransferAccountId = _data["defaultItemTransferAccountId"];
            this.defaultItemProductionAccountId = _data["defaultItemProductionAccountId"];
            this.defaultItemExchangeAccountId = _data["defaultItemExchangeAccountId"];
            this.defaultCashTransferAccountId = _data["defaultCashTransferAccountId"];
            this.defaultCashExchangeAccountId = _data["defaultCashExchangeAccountId"];
        }
    }

    static fromJS(data: any): CreateUpdateCompanyAccountSettingInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateCompanyAccountSettingInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["defaultAPAccountId"] = this.defaultAPAccountId;
        data["defaultARAccountId"] = this.defaultARAccountId;
        data["defaultPurchaseDiscountAccountId"] = this.defaultPurchaseDiscountAccountId;
        data["defaultSaleDiscountAccountId"] = this.defaultSaleDiscountAccountId;
        data["defaultInventoryPurchaseAccountId"] = this.defaultInventoryPurchaseAccountId;
        data["defaultBillPaymentAccountId"] = this.defaultBillPaymentAccountId;
        data["defaultReceivePaymentAccountId"] = this.defaultReceivePaymentAccountId;
        data["defaultRetainEarningAccountId"] = this.defaultRetainEarningAccountId;
        data["defaultExchangeLossGainAccountId"] = this.defaultExchangeLossGainAccountId;
        data["defaultItemReceiptAccountId"] = this.defaultItemReceiptAccountId;
        data["defaultItemIssueAccountId"] = this.defaultItemIssueAccountId;
        data["defaultItemAdjustmentAccountId"] = this.defaultItemAdjustmentAccountId;
        data["defaultItemTransferAccountId"] = this.defaultItemTransferAccountId;
        data["defaultItemProductionAccountId"] = this.defaultItemProductionAccountId;
        data["defaultItemExchangeAccountId"] = this.defaultItemExchangeAccountId;
        data["defaultCashTransferAccountId"] = this.defaultCashTransferAccountId;
        data["defaultCashExchangeAccountId"] = this.defaultCashExchangeAccountId;
        return data;
    }

    clone(): CreateUpdateCompanyAccountSettingInputDto {
        const json = this.toJSON();
        let result = new CreateUpdateCompanyAccountSettingInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateCompanyAccountSettingInputDto {
    id: number | undefined;
    defaultAPAccountId: string | undefined;
    defaultARAccountId: string | undefined;
    defaultPurchaseDiscountAccountId: string | undefined;
    defaultSaleDiscountAccountId: string | undefined;
    defaultInventoryPurchaseAccountId: string | undefined;
    defaultBillPaymentAccountId: string | undefined;
    defaultReceivePaymentAccountId: string | undefined;
    defaultRetainEarningAccountId: string | undefined;
    defaultExchangeLossGainAccountId: string | undefined;
    defaultItemReceiptAccountId: string | undefined;
    defaultItemIssueAccountId: string | undefined;
    defaultItemAdjustmentAccountId: string | undefined;
    defaultItemTransferAccountId: string | undefined;
    defaultItemProductionAccountId: string | undefined;
    defaultItemExchangeAccountId: string | undefined;
    defaultCashTransferAccountId: string | undefined;
    defaultCashExchangeAccountId: string | undefined;
}

export class CreateUpdateCompanyAdvanceSettingInputDto implements ICreateUpdateCompanyAdvanceSettingInputDto {
    id: number | undefined;
    multiBranchesEnable: boolean;
    multiCurrencyEnable: boolean;
    lineDiscountEnable: boolean;
    totalDiscountEnable: boolean;
    customAccountCodeEnable: boolean;
    classEnable: boolean;

    constructor(data?: ICreateUpdateCompanyAdvanceSettingInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.multiBranchesEnable = _data["multiBranchesEnable"];
            this.multiCurrencyEnable = _data["multiCurrencyEnable"];
            this.lineDiscountEnable = _data["lineDiscountEnable"];
            this.totalDiscountEnable = _data["totalDiscountEnable"];
            this.customAccountCodeEnable = _data["customAccountCodeEnable"];
            this.classEnable = _data["classEnable"];
        }
    }

    static fromJS(data: any): CreateUpdateCompanyAdvanceSettingInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateCompanyAdvanceSettingInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["multiBranchesEnable"] = this.multiBranchesEnable;
        data["multiCurrencyEnable"] = this.multiCurrencyEnable;
        data["lineDiscountEnable"] = this.lineDiscountEnable;
        data["totalDiscountEnable"] = this.totalDiscountEnable;
        data["customAccountCodeEnable"] = this.customAccountCodeEnable;
        data["classEnable"] = this.classEnable;
        return data;
    }

    clone(): CreateUpdateCompanyAdvanceSettingInputDto {
        const json = this.toJSON();
        let result = new CreateUpdateCompanyAdvanceSettingInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateCompanyAdvanceSettingInputDto {
    id: number | undefined;
    multiBranchesEnable: boolean;
    multiCurrencyEnable: boolean;
    lineDiscountEnable: boolean;
    totalDiscountEnable: boolean;
    customAccountCodeEnable: boolean;
    classEnable: boolean;
}

export class CreateUpdateCompanyGeneralSettingInputDto implements ICreateUpdateCompanyGeneralSettingInputDto {
    id: number | undefined;
    countryId: string | undefined;
    defaultTimeZone: string | undefined;
    currencyId: number | undefined;
    businessStartDate: moment.Moment | undefined;
    roundTotalDigits: number;
    roundCostDigits: number;
    contactAddressLevel: AddressLevel;

    constructor(data?: ICreateUpdateCompanyGeneralSettingInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.countryId = _data["countryId"];
            this.defaultTimeZone = _data["defaultTimeZone"];
            this.currencyId = _data["currencyId"];
            this.businessStartDate = _data["businessStartDate"] ? moment(_data["businessStartDate"].toString()) : <any>undefined;
            this.roundTotalDigits = _data["roundTotalDigits"];
            this.roundCostDigits = _data["roundCostDigits"];
            this.contactAddressLevel = _data["contactAddressLevel"];
        }
    }

    static fromJS(data: any): CreateUpdateCompanyGeneralSettingInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateCompanyGeneralSettingInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["countryId"] = this.countryId;
        data["defaultTimeZone"] = this.defaultTimeZone;
        data["currencyId"] = this.currencyId;
        data["businessStartDate"] = this.businessStartDate ? this.businessStartDate.toISOString() : <any>undefined;
        data["roundTotalDigits"] = this.roundTotalDigits;
        data["roundCostDigits"] = this.roundCostDigits;
        data["contactAddressLevel"] = this.contactAddressLevel;
        return data;
    }

    clone(): CreateUpdateCompanyGeneralSettingInputDto {
        const json = this.toJSON();
        let result = new CreateUpdateCompanyGeneralSettingInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateCompanyGeneralSettingInputDto {
    id: number | undefined;
    countryId: string | undefined;
    defaultTimeZone: string | undefined;
    currencyId: number | undefined;
    businessStartDate: moment.Moment | undefined;
    roundTotalDigits: number;
    roundCostDigits: number;
    contactAddressLevel: AddressLevel;
}

export class CreateUpdateCountryInputDto implements ICreateUpdateCountryInputDto {
    id: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    code: string | undefined;
    iso: string | undefined;
    isO2: string | undefined;
    phonePrefix: string | undefined;
    currencyId: number | undefined;

    constructor(data?: ICreateUpdateCountryInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.code = _data["code"];
            this.iso = _data["iso"];
            this.isO2 = _data["isO2"];
            this.phonePrefix = _data["phonePrefix"];
            this.currencyId = _data["currencyId"];
        }
    }

    static fromJS(data: any): CreateUpdateCountryInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateCountryInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["code"] = this.code;
        data["iso"] = this.iso;
        data["isO2"] = this.isO2;
        data["phonePrefix"] = this.phonePrefix;
        data["currencyId"] = this.currencyId;
        return data;
    }

    clone(): CreateUpdateCountryInputDto {
        const json = this.toJSON();
        let result = new CreateUpdateCountryInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateCountryInputDto {
    id: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    code: string | undefined;
    iso: string | undefined;
    isO2: string | undefined;
    phonePrefix: string | undefined;
    currencyId: number | undefined;
}

export class CreateUpdateCurrencyInputDto implements ICreateUpdateCurrencyInputDto {
    id: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    code: string | undefined;
    symbol: string | undefined;
    isDefault: boolean;

    constructor(data?: ICreateUpdateCurrencyInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.code = _data["code"];
            this.symbol = _data["symbol"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): CreateUpdateCurrencyInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateCurrencyInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["code"] = this.code;
        data["symbol"] = this.symbol;
        data["isDefault"] = this.isDefault;
        return data;
    }

    clone(): CreateUpdateCurrencyInputDto {
        const json = this.toJSON();
        let result = new CreateUpdateCurrencyInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateCurrencyInputDto {
    id: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    code: string | undefined;
    symbol: string | undefined;
    isDefault: boolean;
}

export class CreateUpdateKhanDistrictInputDto implements ICreateUpdateKhanDistrictInputDto {
    id: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    code: string | undefined;
    countryId: string | undefined;
    cityProvinceId: string | undefined;

    constructor(data?: ICreateUpdateKhanDistrictInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.code = _data["code"];
            this.countryId = _data["countryId"];
            this.cityProvinceId = _data["cityProvinceId"];
        }
    }

    static fromJS(data: any): CreateUpdateKhanDistrictInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateKhanDistrictInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["code"] = this.code;
        data["countryId"] = this.countryId;
        data["cityProvinceId"] = this.cityProvinceId;
        return data;
    }

    clone(): CreateUpdateKhanDistrictInputDto {
        const json = this.toJSON();
        let result = new CreateUpdateKhanDistrictInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateKhanDistrictInputDto {
    id: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    code: string | undefined;
    countryId: string | undefined;
    cityProvinceId: string | undefined;
}

export class CreateUpdateLocationInputDto implements ICreateUpdateLocationInputDto {
    id: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;

    constructor(data?: ICreateUpdateLocationInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): CreateUpdateLocationInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateLocationInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }

    clone(): CreateUpdateLocationInputDto {
        const json = this.toJSON();
        let result = new CreateUpdateLocationInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateLocationInputDto {
    id: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
}

export class CreateUpdateSangkatCommuneInputDto implements ICreateUpdateSangkatCommuneInputDto {
    id: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    code: string | undefined;
    countryId: string | undefined;
    cityProvinceId: string | undefined;
    khanDistrictId: string | undefined;

    constructor(data?: ICreateUpdateSangkatCommuneInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.code = _data["code"];
            this.countryId = _data["countryId"];
            this.cityProvinceId = _data["cityProvinceId"];
            this.khanDistrictId = _data["khanDistrictId"];
        }
    }

    static fromJS(data: any): CreateUpdateSangkatCommuneInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateSangkatCommuneInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["code"] = this.code;
        data["countryId"] = this.countryId;
        data["cityProvinceId"] = this.cityProvinceId;
        data["khanDistrictId"] = this.khanDistrictId;
        return data;
    }

    clone(): CreateUpdateSangkatCommuneInputDto {
        const json = this.toJSON();
        let result = new CreateUpdateSangkatCommuneInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateSangkatCommuneInputDto {
    id: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    code: string | undefined;
    countryId: string | undefined;
    cityProvinceId: string | undefined;
    khanDistrictId: string | undefined;
}

export class CreateUpdateTransactionNoSettingInputDto implements ICreateUpdateTransactionNoSettingInputDto {
    id: string | undefined;
    journalType: JournalType;
    customTransactionNoEnable: boolean;
    prefix: string | undefined;
    digits: number;
    start: number;
    requiredReference: boolean;

    constructor(data?: ICreateUpdateTransactionNoSettingInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.journalType = _data["journalType"];
            this.customTransactionNoEnable = _data["customTransactionNoEnable"];
            this.prefix = _data["prefix"];
            this.digits = _data["digits"];
            this.start = _data["start"];
            this.requiredReference = _data["requiredReference"];
        }
    }

    static fromJS(data: any): CreateUpdateTransactionNoSettingInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateTransactionNoSettingInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["journalType"] = this.journalType;
        data["customTransactionNoEnable"] = this.customTransactionNoEnable;
        data["prefix"] = this.prefix;
        data["digits"] = this.digits;
        data["start"] = this.start;
        data["requiredReference"] = this.requiredReference;
        return data;
    }

    clone(): CreateUpdateTransactionNoSettingInputDto {
        const json = this.toJSON();
        let result = new CreateUpdateTransactionNoSettingInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateTransactionNoSettingInputDto {
    id: string | undefined;
    journalType: JournalType;
    customTransactionNoEnable: boolean;
    prefix: string | undefined;
    digits: number;
    start: number;
    requiredReference: boolean;
}

export class CreateUpdateVillageInputDto implements ICreateUpdateVillageInputDto {
    id: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    code: string | undefined;
    countryId: string | undefined;
    cityProvinceId: string | undefined;
    khanDistrictId: string | undefined;
    sangkatCommuneId: string | undefined;

    constructor(data?: ICreateUpdateVillageInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.code = _data["code"];
            this.countryId = _data["countryId"];
            this.cityProvinceId = _data["cityProvinceId"];
            this.khanDistrictId = _data["khanDistrictId"];
            this.sangkatCommuneId = _data["sangkatCommuneId"];
        }
    }

    static fromJS(data: any): CreateUpdateVillageInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateVillageInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["code"] = this.code;
        data["countryId"] = this.countryId;
        data["cityProvinceId"] = this.cityProvinceId;
        data["khanDistrictId"] = this.khanDistrictId;
        data["sangkatCommuneId"] = this.sangkatCommuneId;
        return data;
    }

    clone(): CreateUpdateVillageInputDto {
        const json = this.toJSON();
        let result = new CreateUpdateVillageInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateVillageInputDto {
    id: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    code: string | undefined;
    countryId: string | undefined;
    cityProvinceId: string | undefined;
    khanDistrictId: string | undefined;
    sangkatCommuneId: string | undefined;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string | undefined;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
    useEmail: boolean;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = _data["password"];
            this.useEmail = _data["useEmail"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        data["useEmail"] = this.useEmail;
        return data;
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string | undefined;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
    useEmail: boolean;
}

export class CurrencyDetailDto implements ICurrencyDetailDto {
    id: number;
    firstId: number | undefined;
    nextId: number | undefined;
    previousId: number | undefined;
    lastId: number | undefined;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    isDefault: boolean;
    code: string | undefined;
    symbol: string | undefined;

    constructor(data?: ICurrencyDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstId = _data["firstId"];
            this.nextId = _data["nextId"];
            this.previousId = _data["previousId"];
            this.lastId = _data["lastId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModifierUserName = _data["lastModifierUserName"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isDefault = _data["isDefault"];
            this.code = _data["code"];
            this.symbol = _data["symbol"];
        }
    }

    static fromJS(data: any): CurrencyDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstId"] = this.firstId;
        data["nextId"] = this.nextId;
        data["previousId"] = this.previousId;
        data["lastId"] = this.lastId;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModifierUserName"] = this.lastModifierUserName;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        data["code"] = this.code;
        data["symbol"] = this.symbol;
        return data;
    }

    clone(): CurrencyDetailDto {
        const json = this.toJSON();
        let result = new CurrencyDetailDto();
        result.init(json);
        return result;
    }
}

export interface ICurrencyDetailDto {
    id: number;
    firstId: number | undefined;
    nextId: number | undefined;
    previousId: number | undefined;
    lastId: number | undefined;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    isDefault: boolean;
    code: string | undefined;
    symbol: string | undefined;
}

export class CurrencyListDto implements ICurrencyListDto {
    id: number;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    isDefault: boolean;
    code: string | undefined;
    symbol: string | undefined;

    constructor(data?: ICurrencyListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModifierUserName = _data["lastModifierUserName"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isDefault = _data["isDefault"];
            this.code = _data["code"];
            this.symbol = _data["symbol"];
        }
    }

    static fromJS(data: any): CurrencyListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModifierUserName"] = this.lastModifierUserName;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        data["code"] = this.code;
        data["symbol"] = this.symbol;
        return data;
    }

    clone(): CurrencyListDto {
        const json = this.toJSON();
        let result = new CurrencyListDto();
        result.init(json);
        return result;
    }
}

export interface ICurrencyListDto {
    id: number;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    isDefault: boolean;
    code: string | undefined;
    symbol: string | undefined;
}

export class CurrencyListDtoPagedResultDto implements ICurrencyListDtoPagedResultDto {
    items: CurrencyListDto[] | undefined;
    totalCount: number;

    constructor(data?: ICurrencyListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CurrencyListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CurrencyListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): CurrencyListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CurrencyListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICurrencyListDtoPagedResultDto {
    items: CurrencyListDto[] | undefined;
    totalCount: number;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.timezone = _data["timezone"];
            this.qrCodeSetupImageUrl = _data["qrCodeSetupImageUrl"];
            this.isGoogleAuthenticatorEnabled = _data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data;
    }

    clone(): CurrentUserProfileEditDto {
        const json = this.toJSON();
        let result = new CurrentUserProfileEditDto();
        result.init(json);
        return result;
    }
}

export interface ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean;
}

export class EditionEditDto implements IEditionEditDto {
    id: number | undefined;
    name: string;
    displayName: string | undefined;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        return data;
    }

    clone(): EditionEditDto {
        const json = this.toJSON();
        let result = new EditionEditDto();
        result.init(json);
        return result;
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    name: string;
    displayName: string | undefined;
}

export class EditionListDto implements IEditionListDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        return data;
    }

    clone(): EditionListDto {
        const json = this.toJSON();
        let result = new EditionListDto();
        result.init(json);
        return result;
    }
}

export interface IEditionListDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
}

export class EditionListDtoPagedResultDto implements IEditionListDtoPagedResultDto {
    items: EditionListDto[] | undefined;
    totalCount: number;

    constructor(data?: IEditionListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(EditionListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EditionListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): EditionListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new EditionListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IEditionListDtoPagedResultDto {
    items: EditionListDto[] | undefined;
    totalCount: number;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data;
    }

    clone(): EmailSettingsEditDto {
        const json = this.toJSON();
        let result = new EmailSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;
}

export class EntityDto implements IEntityDto {
    id: number;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): EntityDto {
        const json = this.toJSON();
        let result = new EntityDto();
        result.init(json);
        return result;
    }
}

export interface IEntityDto {
    id: number;
}

export class ExportAuditLogsInput implements IExportAuditLogsInput {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    userName: string | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    browserInfo: string | undefined;
    hasException: boolean | undefined;
    minExecutionDuration: number | undefined;
    maxExecutionDuration: number | undefined;
    columns: ColumnOutput[] | undefined;

    constructor(data?: IExportAuditLogsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.usePagination = _data["usePagination"];
            this.sortField = _data["sortField"];
            this.sortMode = _data["sortMode"];
            this.keyword = _data["keyword"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.userName = _data["userName"];
            this.serviceName = _data["serviceName"];
            this.methodName = _data["methodName"];
            this.browserInfo = _data["browserInfo"];
            this.hasException = _data["hasException"];
            this.minExecutionDuration = _data["minExecutionDuration"];
            this.maxExecutionDuration = _data["maxExecutionDuration"];
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(ColumnOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExportAuditLogsInput {
        data = typeof data === 'object' ? data : {};
        let result = new ExportAuditLogsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["usePagination"] = this.usePagination;
        data["sortField"] = this.sortField;
        data["sortMode"] = this.sortMode;
        data["keyword"] = this.keyword;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["userName"] = this.userName;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["browserInfo"] = this.browserInfo;
        data["hasException"] = this.hasException;
        data["minExecutionDuration"] = this.minExecutionDuration;
        data["maxExecutionDuration"] = this.maxExecutionDuration;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        return data;
    }

    clone(): ExportAuditLogsInput {
        const json = this.toJSON();
        let result = new ExportAuditLogsInput();
        result.init(json);
        return result;
    }
}

export interface IExportAuditLogsInput {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    userName: string | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    browserInfo: string | undefined;
    hasException: boolean | undefined;
    minExecutionDuration: number | undefined;
    maxExecutionDuration: number | undefined;
    columns: ColumnOutput[] | undefined;
}

export class ExportExcelBranchInputDto implements IExportExcelBranchInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    columns: ColumnOutput[] | undefined;

    constructor(data?: IExportExcelBranchInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.usePagination = _data["usePagination"];
            this.sortField = _data["sortField"];
            this.sortMode = _data["sortMode"];
            this.keyword = _data["keyword"];
            this.creators = _data["creators"] ? Int64NullableFilterInputDto.fromJS(_data["creators"]) : <any>undefined;
            this.modifiers = _data["modifiers"] ? Int64NullableFilterInputDto.fromJS(_data["modifiers"]) : <any>undefined;
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(ColumnOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExportExcelBranchInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExportExcelBranchInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["usePagination"] = this.usePagination;
        data["sortField"] = this.sortField;
        data["sortMode"] = this.sortMode;
        data["keyword"] = this.keyword;
        data["creators"] = this.creators ? this.creators.toJSON() : <any>undefined;
        data["modifiers"] = this.modifiers ? this.modifiers.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        return data;
    }

    clone(): ExportExcelBranchInputDto {
        const json = this.toJSON();
        let result = new ExportExcelBranchInputDto();
        result.init(json);
        return result;
    }
}

export interface IExportExcelBranchInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    columns: ColumnOutput[] | undefined;
}

export class ExportExcelChartOfAccountInputDto implements IExportExcelChartOfAccountInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    accountTypeFilter: AccountTypeFilterInputDto;
    subAccountTypeFilter: SubAccountTypeFilterInputDto;
    parentFilter: GuidNullableFilterInputDto;
    columns: ColumnOutput[] | undefined;

    constructor(data?: IExportExcelChartOfAccountInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.usePagination = _data["usePagination"];
            this.sortField = _data["sortField"];
            this.sortMode = _data["sortMode"];
            this.keyword = _data["keyword"];
            this.creators = _data["creators"] ? Int64NullableFilterInputDto.fromJS(_data["creators"]) : <any>undefined;
            this.modifiers = _data["modifiers"] ? Int64NullableFilterInputDto.fromJS(_data["modifiers"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.accountTypeFilter = _data["accountTypeFilter"] ? AccountTypeFilterInputDto.fromJS(_data["accountTypeFilter"]) : <any>undefined;
            this.subAccountTypeFilter = _data["subAccountTypeFilter"] ? SubAccountTypeFilterInputDto.fromJS(_data["subAccountTypeFilter"]) : <any>undefined;
            this.parentFilter = _data["parentFilter"] ? GuidNullableFilterInputDto.fromJS(_data["parentFilter"]) : <any>undefined;
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(ColumnOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExportExcelChartOfAccountInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExportExcelChartOfAccountInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["usePagination"] = this.usePagination;
        data["sortField"] = this.sortField;
        data["sortMode"] = this.sortMode;
        data["keyword"] = this.keyword;
        data["creators"] = this.creators ? this.creators.toJSON() : <any>undefined;
        data["modifiers"] = this.modifiers ? this.modifiers.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["accountTypeFilter"] = this.accountTypeFilter ? this.accountTypeFilter.toJSON() : <any>undefined;
        data["subAccountTypeFilter"] = this.subAccountTypeFilter ? this.subAccountTypeFilter.toJSON() : <any>undefined;
        data["parentFilter"] = this.parentFilter ? this.parentFilter.toJSON() : <any>undefined;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        return data;
    }

    clone(): ExportExcelChartOfAccountInputDto {
        const json = this.toJSON();
        let result = new ExportExcelChartOfAccountInputDto();
        result.init(json);
        return result;
    }
}

export interface IExportExcelChartOfAccountInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    accountTypeFilter: AccountTypeFilterInputDto;
    subAccountTypeFilter: SubAccountTypeFilterInputDto;
    parentFilter: GuidNullableFilterInputDto;
    columns: ColumnOutput[] | undefined;
}

export class ExportExcelCityProvinceInputDto implements IExportExcelCityProvinceInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    countries: GuidNullableFilterInputDto;
    columns: ColumnOutput[] | undefined;

    constructor(data?: IExportExcelCityProvinceInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.usePagination = _data["usePagination"];
            this.sortField = _data["sortField"];
            this.sortMode = _data["sortMode"];
            this.keyword = _data["keyword"];
            this.creators = _data["creators"] ? Int64NullableFilterInputDto.fromJS(_data["creators"]) : <any>undefined;
            this.modifiers = _data["modifiers"] ? Int64NullableFilterInputDto.fromJS(_data["modifiers"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.countries = _data["countries"] ? GuidNullableFilterInputDto.fromJS(_data["countries"]) : <any>undefined;
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(ColumnOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExportExcelCityProvinceInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExportExcelCityProvinceInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["usePagination"] = this.usePagination;
        data["sortField"] = this.sortField;
        data["sortMode"] = this.sortMode;
        data["keyword"] = this.keyword;
        data["creators"] = this.creators ? this.creators.toJSON() : <any>undefined;
        data["modifiers"] = this.modifiers ? this.modifiers.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["countries"] = this.countries ? this.countries.toJSON() : <any>undefined;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        return data;
    }

    clone(): ExportExcelCityProvinceInputDto {
        const json = this.toJSON();
        let result = new ExportExcelCityProvinceInputDto();
        result.init(json);
        return result;
    }
}

export interface IExportExcelCityProvinceInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    countries: GuidNullableFilterInputDto;
    columns: ColumnOutput[] | undefined;
}

export class ExportExcelCountryInputDto implements IExportExcelCountryInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    currencies: Int64FilterInputDto;
    columns: ColumnOutput[] | undefined;

    constructor(data?: IExportExcelCountryInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.usePagination = _data["usePagination"];
            this.sortField = _data["sortField"];
            this.sortMode = _data["sortMode"];
            this.keyword = _data["keyword"];
            this.creators = _data["creators"] ? Int64NullableFilterInputDto.fromJS(_data["creators"]) : <any>undefined;
            this.modifiers = _data["modifiers"] ? Int64NullableFilterInputDto.fromJS(_data["modifiers"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.currencies = _data["currencies"] ? Int64FilterInputDto.fromJS(_data["currencies"]) : <any>undefined;
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(ColumnOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExportExcelCountryInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExportExcelCountryInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["usePagination"] = this.usePagination;
        data["sortField"] = this.sortField;
        data["sortMode"] = this.sortMode;
        data["keyword"] = this.keyword;
        data["creators"] = this.creators ? this.creators.toJSON() : <any>undefined;
        data["modifiers"] = this.modifiers ? this.modifiers.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["currencies"] = this.currencies ? this.currencies.toJSON() : <any>undefined;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        return data;
    }

    clone(): ExportExcelCountryInputDto {
        const json = this.toJSON();
        let result = new ExportExcelCountryInputDto();
        result.init(json);
        return result;
    }
}

export interface IExportExcelCountryInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    currencies: Int64FilterInputDto;
    columns: ColumnOutput[] | undefined;
}

export class ExportExcelCurrencyInputDto implements IExportExcelCurrencyInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    columns: ColumnOutput[] | undefined;

    constructor(data?: IExportExcelCurrencyInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.usePagination = _data["usePagination"];
            this.sortField = _data["sortField"];
            this.sortMode = _data["sortMode"];
            this.keyword = _data["keyword"];
            this.creators = _data["creators"] ? Int64NullableFilterInputDto.fromJS(_data["creators"]) : <any>undefined;
            this.modifiers = _data["modifiers"] ? Int64NullableFilterInputDto.fromJS(_data["modifiers"]) : <any>undefined;
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(ColumnOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExportExcelCurrencyInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExportExcelCurrencyInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["usePagination"] = this.usePagination;
        data["sortField"] = this.sortField;
        data["sortMode"] = this.sortMode;
        data["keyword"] = this.keyword;
        data["creators"] = this.creators ? this.creators.toJSON() : <any>undefined;
        data["modifiers"] = this.modifiers ? this.modifiers.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        return data;
    }

    clone(): ExportExcelCurrencyInputDto {
        const json = this.toJSON();
        let result = new ExportExcelCurrencyInputDto();
        result.init(json);
        return result;
    }
}

export interface IExportExcelCurrencyInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    columns: ColumnOutput[] | undefined;
}

export class ExportExcelKhanDistrictInputDto implements IExportExcelKhanDistrictInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    countries: GuidNullableFilterInputDto;
    cityProvinces: GuidNullableFilterInputDto;
    columns: ColumnOutput[] | undefined;

    constructor(data?: IExportExcelKhanDistrictInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.usePagination = _data["usePagination"];
            this.sortField = _data["sortField"];
            this.sortMode = _data["sortMode"];
            this.keyword = _data["keyword"];
            this.creators = _data["creators"] ? Int64NullableFilterInputDto.fromJS(_data["creators"]) : <any>undefined;
            this.modifiers = _data["modifiers"] ? Int64NullableFilterInputDto.fromJS(_data["modifiers"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.countries = _data["countries"] ? GuidNullableFilterInputDto.fromJS(_data["countries"]) : <any>undefined;
            this.cityProvinces = _data["cityProvinces"] ? GuidNullableFilterInputDto.fromJS(_data["cityProvinces"]) : <any>undefined;
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(ColumnOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExportExcelKhanDistrictInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExportExcelKhanDistrictInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["usePagination"] = this.usePagination;
        data["sortField"] = this.sortField;
        data["sortMode"] = this.sortMode;
        data["keyword"] = this.keyword;
        data["creators"] = this.creators ? this.creators.toJSON() : <any>undefined;
        data["modifiers"] = this.modifiers ? this.modifiers.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["countries"] = this.countries ? this.countries.toJSON() : <any>undefined;
        data["cityProvinces"] = this.cityProvinces ? this.cityProvinces.toJSON() : <any>undefined;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        return data;
    }

    clone(): ExportExcelKhanDistrictInputDto {
        const json = this.toJSON();
        let result = new ExportExcelKhanDistrictInputDto();
        result.init(json);
        return result;
    }
}

export interface IExportExcelKhanDistrictInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    countries: GuidNullableFilterInputDto;
    cityProvinces: GuidNullableFilterInputDto;
    columns: ColumnOutput[] | undefined;
}

export class ExportExcelLocationInputDto implements IExportExcelLocationInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    columns: ColumnOutput[] | undefined;

    constructor(data?: IExportExcelLocationInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.usePagination = _data["usePagination"];
            this.sortField = _data["sortField"];
            this.sortMode = _data["sortMode"];
            this.keyword = _data["keyword"];
            this.creators = _data["creators"] ? Int64NullableFilterInputDto.fromJS(_data["creators"]) : <any>undefined;
            this.modifiers = _data["modifiers"] ? Int64NullableFilterInputDto.fromJS(_data["modifiers"]) : <any>undefined;
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(ColumnOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExportExcelLocationInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExportExcelLocationInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["usePagination"] = this.usePagination;
        data["sortField"] = this.sortField;
        data["sortMode"] = this.sortMode;
        data["keyword"] = this.keyword;
        data["creators"] = this.creators ? this.creators.toJSON() : <any>undefined;
        data["modifiers"] = this.modifiers ? this.modifiers.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        return data;
    }

    clone(): ExportExcelLocationInputDto {
        const json = this.toJSON();
        let result = new ExportExcelLocationInputDto();
        result.init(json);
        return result;
    }
}

export interface IExportExcelLocationInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    columns: ColumnOutput[] | undefined;
}

export class ExportExcelSangkatCommuneInputDto implements IExportExcelSangkatCommuneInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    countries: GuidNullableFilterInputDto;
    cityProvinces: GuidNullableFilterInputDto;
    khanDistricts: GuidNullableFilterInputDto;
    columns: ColumnOutput[] | undefined;

    constructor(data?: IExportExcelSangkatCommuneInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.usePagination = _data["usePagination"];
            this.sortField = _data["sortField"];
            this.sortMode = _data["sortMode"];
            this.keyword = _data["keyword"];
            this.creators = _data["creators"] ? Int64NullableFilterInputDto.fromJS(_data["creators"]) : <any>undefined;
            this.modifiers = _data["modifiers"] ? Int64NullableFilterInputDto.fromJS(_data["modifiers"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.countries = _data["countries"] ? GuidNullableFilterInputDto.fromJS(_data["countries"]) : <any>undefined;
            this.cityProvinces = _data["cityProvinces"] ? GuidNullableFilterInputDto.fromJS(_data["cityProvinces"]) : <any>undefined;
            this.khanDistricts = _data["khanDistricts"] ? GuidNullableFilterInputDto.fromJS(_data["khanDistricts"]) : <any>undefined;
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(ColumnOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExportExcelSangkatCommuneInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExportExcelSangkatCommuneInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["usePagination"] = this.usePagination;
        data["sortField"] = this.sortField;
        data["sortMode"] = this.sortMode;
        data["keyword"] = this.keyword;
        data["creators"] = this.creators ? this.creators.toJSON() : <any>undefined;
        data["modifiers"] = this.modifiers ? this.modifiers.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["countries"] = this.countries ? this.countries.toJSON() : <any>undefined;
        data["cityProvinces"] = this.cityProvinces ? this.cityProvinces.toJSON() : <any>undefined;
        data["khanDistricts"] = this.khanDistricts ? this.khanDistricts.toJSON() : <any>undefined;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        return data;
    }

    clone(): ExportExcelSangkatCommuneInputDto {
        const json = this.toJSON();
        let result = new ExportExcelSangkatCommuneInputDto();
        result.init(json);
        return result;
    }
}

export interface IExportExcelSangkatCommuneInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    countries: GuidNullableFilterInputDto;
    cityProvinces: GuidNullableFilterInputDto;
    khanDistricts: GuidNullableFilterInputDto;
    columns: ColumnOutput[] | undefined;
}

export class ExportExcelVillageInputDto implements IExportExcelVillageInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    countries: GuidNullableFilterInputDto;
    cityProvinces: GuidNullableFilterInputDto;
    khanDistricts: GuidNullableFilterInputDto;
    sangkatCommunes: GuidNullableFilterInputDto;
    columns: ColumnOutput[] | undefined;

    constructor(data?: IExportExcelVillageInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.usePagination = _data["usePagination"];
            this.sortField = _data["sortField"];
            this.sortMode = _data["sortMode"];
            this.keyword = _data["keyword"];
            this.creators = _data["creators"] ? Int64NullableFilterInputDto.fromJS(_data["creators"]) : <any>undefined;
            this.modifiers = _data["modifiers"] ? Int64NullableFilterInputDto.fromJS(_data["modifiers"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.countries = _data["countries"] ? GuidNullableFilterInputDto.fromJS(_data["countries"]) : <any>undefined;
            this.cityProvinces = _data["cityProvinces"] ? GuidNullableFilterInputDto.fromJS(_data["cityProvinces"]) : <any>undefined;
            this.khanDistricts = _data["khanDistricts"] ? GuidNullableFilterInputDto.fromJS(_data["khanDistricts"]) : <any>undefined;
            this.sangkatCommunes = _data["sangkatCommunes"] ? GuidNullableFilterInputDto.fromJS(_data["sangkatCommunes"]) : <any>undefined;
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(ColumnOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExportExcelVillageInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExportExcelVillageInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["usePagination"] = this.usePagination;
        data["sortField"] = this.sortField;
        data["sortMode"] = this.sortMode;
        data["keyword"] = this.keyword;
        data["creators"] = this.creators ? this.creators.toJSON() : <any>undefined;
        data["modifiers"] = this.modifiers ? this.modifiers.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["countries"] = this.countries ? this.countries.toJSON() : <any>undefined;
        data["cityProvinces"] = this.cityProvinces ? this.cityProvinces.toJSON() : <any>undefined;
        data["khanDistricts"] = this.khanDistricts ? this.khanDistricts.toJSON() : <any>undefined;
        data["sangkatCommunes"] = this.sangkatCommunes ? this.sangkatCommunes.toJSON() : <any>undefined;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        return data;
    }

    clone(): ExportExcelVillageInputDto {
        const json = this.toJSON();
        let result = new ExportExcelVillageInputDto();
        result.init(json);
        return result;
    }
}

export interface IExportExcelVillageInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    countries: GuidNullableFilterInputDto;
    cityProvinces: GuidNullableFilterInputDto;
    khanDistricts: GuidNullableFilterInputDto;
    sangkatCommunes: GuidNullableFilterInputDto;
    columns: ColumnOutput[] | undefined;
}

export class ExportFileOutput implements IExportFileOutput {
    fileName: string;
    fileToken: string;
    fileUrl: string | undefined;

    constructor(data?: IExportFileOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileToken = _data["fileToken"];
            this.fileUrl = _data["fileUrl"];
        }
    }

    static fromJS(data: any): ExportFileOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ExportFileOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileToken"] = this.fileToken;
        data["fileUrl"] = this.fileUrl;
        return data;
    }

    clone(): ExportFileOutput {
        const json = this.toJSON();
        let result = new ExportFileOutput();
        result.init(json);
        return result;
    }
}

export interface IExportFileOutput {
    fileName: string;
    fileToken: string;
    fileUrl: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data;
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data;
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data;
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
    validator: IValueValidator;
    itemSource: LocalizableComboboxItemSourceDto;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (_data["attributes"]) {
                this.attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>this.attributes)[key] = _data["attributes"][key];
                }
            }
            this.validator = _data["validator"] ? IValueValidator.fromJS(_data["validator"]) : <any>undefined;
            this.itemSource = _data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(_data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = (<any>this.attributes)[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data;
    }

    clone(): FeatureInputTypeDto {
        const json = this.toJSON();
        let result = new FeatureInputTypeDto();
        result.init(json);
        return result;
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
    validator: IValueValidator;
    itemSource: LocalizableComboboxItemSourceDto;
}

export class FileTokenInput implements IFileTokenInput {
    token: string | undefined;

    constructor(data?: IFileTokenInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): FileTokenInput {
        data = typeof data === 'object' ? data : {};
        let result = new FileTokenInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }

    clone(): FileTokenInput {
        const json = this.toJSON();
        let result = new FileTokenInput();
        result.init(json);
        return result;
    }
}

export interface IFileTokenInput {
    token: string | undefined;
}

export class FindBranchDto implements IFindBranchDto {
    id: string;
    name: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    isDefault: boolean;
    businessId: string | undefined;
    phoneNumber: string | undefined;

    constructor(data?: IFindBranchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            this.isDefault = _data["isDefault"];
            this.businessId = _data["businessId"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): FindBranchDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindBranchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        data["isDefault"] = this.isDefault;
        data["businessId"] = this.businessId;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }

    clone(): FindBranchDto {
        const json = this.toJSON();
        let result = new FindBranchDto();
        result.init(json);
        return result;
    }
}

export interface IFindBranchDto {
    id: string;
    name: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    isDefault: boolean;
    businessId: string | undefined;
    phoneNumber: string | undefined;
}

export class FindBranchDtoPagedResultDto implements IFindBranchDtoPagedResultDto {
    items: FindBranchDto[] | undefined;
    totalCount: number;

    constructor(data?: IFindBranchDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FindBranchDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FindBranchDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindBranchDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): FindBranchDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FindBranchDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFindBranchDtoPagedResultDto {
    items: FindBranchDto[] | undefined;
    totalCount: number;
}

export class FindChartOfAccountDto implements IFindChartOfAccountDto {
    id: string;
    name: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    code: string | undefined;
    accountType: string | undefined;
    subAccountType: string | undefined;
    parentAccount: string | undefined;

    constructor(data?: IFindChartOfAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            this.code = _data["code"];
            this.accountType = _data["accountType"];
            this.subAccountType = _data["subAccountType"];
            this.parentAccount = _data["parentAccount"];
        }
    }

    static fromJS(data: any): FindChartOfAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindChartOfAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        data["code"] = this.code;
        data["accountType"] = this.accountType;
        data["subAccountType"] = this.subAccountType;
        data["parentAccount"] = this.parentAccount;
        return data;
    }

    clone(): FindChartOfAccountDto {
        const json = this.toJSON();
        let result = new FindChartOfAccountDto();
        result.init(json);
        return result;
    }
}

export interface IFindChartOfAccountDto {
    id: string;
    name: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    code: string | undefined;
    accountType: string | undefined;
    subAccountType: string | undefined;
    parentAccount: string | undefined;
}

export class FindChartOfAccountDtoPagedResultDto implements IFindChartOfAccountDtoPagedResultDto {
    items: FindChartOfAccountDto[] | undefined;
    totalCount: number;

    constructor(data?: IFindChartOfAccountDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FindChartOfAccountDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FindChartOfAccountDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindChartOfAccountDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): FindChartOfAccountDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FindChartOfAccountDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFindChartOfAccountDtoPagedResultDto {
    items: FindChartOfAccountDto[] | undefined;
    totalCount: number;
}

export class FindChartOfAccountInputDto implements IFindChartOfAccountInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    accountTypeFilter: AccountTypeFilterInputDto;
    subAccountTypeFilter: SubAccountTypeFilterInputDto;
    parentFilter: GuidNullableFilterInputDto;
    excludeSubAccount: boolean;

    constructor(data?: IFindChartOfAccountInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.usePagination = _data["usePagination"];
            this.sortField = _data["sortField"];
            this.sortMode = _data["sortMode"];
            this.keyword = _data["keyword"];
            this.creators = _data["creators"] ? Int64NullableFilterInputDto.fromJS(_data["creators"]) : <any>undefined;
            this.modifiers = _data["modifiers"] ? Int64NullableFilterInputDto.fromJS(_data["modifiers"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.accountTypeFilter = _data["accountTypeFilter"] ? AccountTypeFilterInputDto.fromJS(_data["accountTypeFilter"]) : <any>undefined;
            this.subAccountTypeFilter = _data["subAccountTypeFilter"] ? SubAccountTypeFilterInputDto.fromJS(_data["subAccountTypeFilter"]) : <any>undefined;
            this.parentFilter = _data["parentFilter"] ? GuidNullableFilterInputDto.fromJS(_data["parentFilter"]) : <any>undefined;
            this.excludeSubAccount = _data["excludeSubAccount"];
        }
    }

    static fromJS(data: any): FindChartOfAccountInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindChartOfAccountInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["usePagination"] = this.usePagination;
        data["sortField"] = this.sortField;
        data["sortMode"] = this.sortMode;
        data["keyword"] = this.keyword;
        data["creators"] = this.creators ? this.creators.toJSON() : <any>undefined;
        data["modifiers"] = this.modifiers ? this.modifiers.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["accountTypeFilter"] = this.accountTypeFilter ? this.accountTypeFilter.toJSON() : <any>undefined;
        data["subAccountTypeFilter"] = this.subAccountTypeFilter ? this.subAccountTypeFilter.toJSON() : <any>undefined;
        data["parentFilter"] = this.parentFilter ? this.parentFilter.toJSON() : <any>undefined;
        data["excludeSubAccount"] = this.excludeSubAccount;
        return data;
    }

    clone(): FindChartOfAccountInputDto {
        const json = this.toJSON();
        let result = new FindChartOfAccountInputDto();
        result.init(json);
        return result;
    }
}

export interface IFindChartOfAccountInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    accountTypeFilter: AccountTypeFilterInputDto;
    subAccountTypeFilter: SubAccountTypeFilterInputDto;
    parentFilter: GuidNullableFilterInputDto;
    excludeSubAccount: boolean;
}

export class FindCityProvinceDto implements IFindCityProvinceDto {
    id: string;
    name: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    code: string | undefined;
    iso: string | undefined;
    countryName: string | undefined;

    constructor(data?: IFindCityProvinceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            this.code = _data["code"];
            this.iso = _data["iso"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): FindCityProvinceDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindCityProvinceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        data["code"] = this.code;
        data["iso"] = this.iso;
        data["countryName"] = this.countryName;
        return data;
    }

    clone(): FindCityProvinceDto {
        const json = this.toJSON();
        let result = new FindCityProvinceDto();
        result.init(json);
        return result;
    }
}

export interface IFindCityProvinceDto {
    id: string;
    name: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    code: string | undefined;
    iso: string | undefined;
    countryName: string | undefined;
}

export class FindCityProvinceDtoPagedResultDto implements IFindCityProvinceDtoPagedResultDto {
    items: FindCityProvinceDto[] | undefined;
    totalCount: number;

    constructor(data?: IFindCityProvinceDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FindCityProvinceDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FindCityProvinceDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindCityProvinceDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): FindCityProvinceDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FindCityProvinceDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFindCityProvinceDtoPagedResultDto {
    items: FindCityProvinceDto[] | undefined;
    totalCount: number;
}

export class FindCountryDto implements IFindCountryDto {
    id: string;
    name: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    code: string | undefined;
    iso: string | undefined;
    isO2: string | undefined;
    phonePrefix: string | undefined;
    currencyId: number | undefined;
    currencyCode: string | undefined;

    constructor(data?: IFindCountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            this.code = _data["code"];
            this.iso = _data["iso"];
            this.isO2 = _data["isO2"];
            this.phonePrefix = _data["phonePrefix"];
            this.currencyId = _data["currencyId"];
            this.currencyCode = _data["currencyCode"];
        }
    }

    static fromJS(data: any): FindCountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindCountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        data["code"] = this.code;
        data["iso"] = this.iso;
        data["isO2"] = this.isO2;
        data["phonePrefix"] = this.phonePrefix;
        data["currencyId"] = this.currencyId;
        data["currencyCode"] = this.currencyCode;
        return data;
    }

    clone(): FindCountryDto {
        const json = this.toJSON();
        let result = new FindCountryDto();
        result.init(json);
        return result;
    }
}

export interface IFindCountryDto {
    id: string;
    name: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    code: string | undefined;
    iso: string | undefined;
    isO2: string | undefined;
    phonePrefix: string | undefined;
    currencyId: number | undefined;
    currencyCode: string | undefined;
}

export class FindCountryDtoPagedResultDto implements IFindCountryDtoPagedResultDto {
    items: FindCountryDto[] | undefined;
    totalCount: number;

    constructor(data?: IFindCountryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FindCountryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FindCountryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindCountryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): FindCountryDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FindCountryDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFindCountryDtoPagedResultDto {
    items: FindCountryDto[] | undefined;
    totalCount: number;
}

export class FindCurrencyDto implements IFindCurrencyDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    isDefault: boolean;
    code: string | undefined;
    symbol: string | undefined;

    constructor(data?: IFindCurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            this.isDefault = _data["isDefault"];
            this.code = _data["code"];
            this.symbol = _data["symbol"];
        }
    }

    static fromJS(data: any): FindCurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindCurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        data["isDefault"] = this.isDefault;
        data["code"] = this.code;
        data["symbol"] = this.symbol;
        return data;
    }

    clone(): FindCurrencyDto {
        const json = this.toJSON();
        let result = new FindCurrencyDto();
        result.init(json);
        return result;
    }
}

export interface IFindCurrencyDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    isDefault: boolean;
    code: string | undefined;
    symbol: string | undefined;
}

export class FindCurrencyDtoPagedResultDto implements IFindCurrencyDtoPagedResultDto {
    items: FindCurrencyDto[] | undefined;
    totalCount: number;

    constructor(data?: IFindCurrencyDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FindCurrencyDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FindCurrencyDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindCurrencyDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): FindCurrencyDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FindCurrencyDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFindCurrencyDtoPagedResultDto {
    items: FindCurrencyDto[] | undefined;
    totalCount: number;
}

export class FindKhanDistrictDto implements IFindKhanDistrictDto {
    id: string;
    name: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    code: string | undefined;
    countryName: string | undefined;
    cityProvinceName: string | undefined;

    constructor(data?: IFindKhanDistrictDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            this.code = _data["code"];
            this.countryName = _data["countryName"];
            this.cityProvinceName = _data["cityProvinceName"];
        }
    }

    static fromJS(data: any): FindKhanDistrictDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindKhanDistrictDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        data["code"] = this.code;
        data["countryName"] = this.countryName;
        data["cityProvinceName"] = this.cityProvinceName;
        return data;
    }

    clone(): FindKhanDistrictDto {
        const json = this.toJSON();
        let result = new FindKhanDistrictDto();
        result.init(json);
        return result;
    }
}

export interface IFindKhanDistrictDto {
    id: string;
    name: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    code: string | undefined;
    countryName: string | undefined;
    cityProvinceName: string | undefined;
}

export class FindKhanDistrictDtoPagedResultDto implements IFindKhanDistrictDtoPagedResultDto {
    items: FindKhanDistrictDto[] | undefined;
    totalCount: number;

    constructor(data?: IFindKhanDistrictDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FindKhanDistrictDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FindKhanDistrictDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindKhanDistrictDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): FindKhanDistrictDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FindKhanDistrictDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFindKhanDistrictDtoPagedResultDto {
    items: FindKhanDistrictDto[] | undefined;
    totalCount: number;
}

export class FindLocationDto implements IFindLocationDto {
    id: string;
    name: string | undefined;
    displayName: string | undefined;
    isActive: boolean;

    constructor(data?: IFindLocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): FindLocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindLocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): FindLocationDto {
        const json = this.toJSON();
        let result = new FindLocationDto();
        result.init(json);
        return result;
    }
}

export interface IFindLocationDto {
    id: string;
    name: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
}

export class FindLocationDtoPagedResultDto implements IFindLocationDtoPagedResultDto {
    items: FindLocationDto[] | undefined;
    totalCount: number;

    constructor(data?: IFindLocationDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FindLocationDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FindLocationDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindLocationDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): FindLocationDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FindLocationDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFindLocationDtoPagedResultDto {
    items: FindLocationDto[] | undefined;
    totalCount: number;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    keyword: string | undefined;
    organizationUnitId: number;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.usePagination = _data["usePagination"];
            this.keyword = _data["keyword"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["usePagination"] = this.usePagination;
        data["keyword"] = this.keyword;
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }

    clone(): FindOrganizationUnitUsersInput {
        const json = this.toJSON();
        let result = new FindOrganizationUnitUsersInput();
        result.init(json);
        return result;
    }
}

export interface IFindOrganizationUnitUsersInput {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    keyword: string | undefined;
    organizationUnitId: number;
}

export class FindSangkatCommuneDto implements IFindSangkatCommuneDto {
    id: string;
    name: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    code: string | undefined;
    countryName: string | undefined;
    cityProvinceName: string | undefined;
    khanDistrictName: string | undefined;

    constructor(data?: IFindSangkatCommuneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            this.code = _data["code"];
            this.countryName = _data["countryName"];
            this.cityProvinceName = _data["cityProvinceName"];
            this.khanDistrictName = _data["khanDistrictName"];
        }
    }

    static fromJS(data: any): FindSangkatCommuneDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindSangkatCommuneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        data["code"] = this.code;
        data["countryName"] = this.countryName;
        data["cityProvinceName"] = this.cityProvinceName;
        data["khanDistrictName"] = this.khanDistrictName;
        return data;
    }

    clone(): FindSangkatCommuneDto {
        const json = this.toJSON();
        let result = new FindSangkatCommuneDto();
        result.init(json);
        return result;
    }
}

export interface IFindSangkatCommuneDto {
    id: string;
    name: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    code: string | undefined;
    countryName: string | undefined;
    cityProvinceName: string | undefined;
    khanDistrictName: string | undefined;
}

export class FindSangkatCommuneDtoPagedResultDto implements IFindSangkatCommuneDtoPagedResultDto {
    items: FindSangkatCommuneDto[] | undefined;
    totalCount: number;

    constructor(data?: IFindSangkatCommuneDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FindSangkatCommuneDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FindSangkatCommuneDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindSangkatCommuneDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): FindSangkatCommuneDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FindSangkatCommuneDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFindSangkatCommuneDtoPagedResultDto {
    items: FindSangkatCommuneDto[] | undefined;
    totalCount: number;
}

export class FindUsersInput implements IFindUsersInput {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    isActive: boolean | undefined;
    tenantId: number | undefined;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.usePagination = _data["usePagination"];
            this.sortField = _data["sortField"];
            this.sortMode = _data["sortMode"];
            this.keyword = _data["keyword"];
            this.isActive = _data["isActive"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["usePagination"] = this.usePagination;
        data["sortField"] = this.sortField;
        data["sortMode"] = this.sortMode;
        data["keyword"] = this.keyword;
        data["isActive"] = this.isActive;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): FindUsersInput {
        const json = this.toJSON();
        let result = new FindUsersInput();
        result.init(json);
        return result;
    }
}

export interface IFindUsersInput {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    isActive: boolean | undefined;
    tenantId: number | undefined;
}

export class FindVillageDto implements IFindVillageDto {
    id: string;
    name: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    code: string | undefined;
    countryName: string | undefined;
    cityProvinceName: string | undefined;
    khanDistrictName: string | undefined;
    sangkatCommuneName: string | undefined;

    constructor(data?: IFindVillageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            this.code = _data["code"];
            this.countryName = _data["countryName"];
            this.cityProvinceName = _data["cityProvinceName"];
            this.khanDistrictName = _data["khanDistrictName"];
            this.sangkatCommuneName = _data["sangkatCommuneName"];
        }
    }

    static fromJS(data: any): FindVillageDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindVillageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        data["code"] = this.code;
        data["countryName"] = this.countryName;
        data["cityProvinceName"] = this.cityProvinceName;
        data["khanDistrictName"] = this.khanDistrictName;
        data["sangkatCommuneName"] = this.sangkatCommuneName;
        return data;
    }

    clone(): FindVillageDto {
        const json = this.toJSON();
        let result = new FindVillageDto();
        result.init(json);
        return result;
    }
}

export interface IFindVillageDto {
    id: string;
    name: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    code: string | undefined;
    countryName: string | undefined;
    cityProvinceName: string | undefined;
    khanDistrictName: string | undefined;
    sangkatCommuneName: string | undefined;
}

export class FindVillageDtoPagedResultDto implements IFindVillageDtoPagedResultDto {
    items: FindVillageDto[] | undefined;
    totalCount: number;

    constructor(data?: IFindVillageDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FindVillageDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FindVillageDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindVillageDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): FindVillageDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FindVillageDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFindVillageDtoPagedResultDto {
    items: FindVillageDto[] | undefined;
    totalCount: number;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.defaultValue = _data["defaultValue"];
            this.inputType = _data["inputType"] ? FeatureInputTypeDto.fromJS(_data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data;
    }

    clone(): FlatFeatureDto {
        const json = this.toJSON();
        let result = new FlatFeatureDto();
        result.init(json);
        return result;
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto;
}

export class FlatFeatureDtoListResultDto implements IFlatFeatureDtoListResultDto {
    items: FlatFeatureDto[] | undefined;

    constructor(data?: IFlatFeatureDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FlatFeatureDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): FlatFeatureDtoListResultDto {
        const json = this.toJSON();
        let result = new FlatFeatureDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IFlatFeatureDtoListResultDto {
    items: FlatFeatureDto[] | undefined;
}

export class GeneralSettingDto implements IGeneralSettingDto {
    countryId: string | undefined;
    countryName: string | undefined;
    defaultTimeZone: string | undefined;
    currencyId: number | undefined;
    currencyCode: string | undefined;
    businessStartDate: moment.Moment | undefined;
    roundTotalDigits: number;
    roundCostDigits: number;
    contactAddressLevel: AddressLevel;

    constructor(data?: IGeneralSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.defaultTimeZone = _data["defaultTimeZone"];
            this.currencyId = _data["currencyId"];
            this.currencyCode = _data["currencyCode"];
            this.businessStartDate = _data["businessStartDate"] ? moment(_data["businessStartDate"].toString()) : <any>undefined;
            this.roundTotalDigits = _data["roundTotalDigits"];
            this.roundCostDigits = _data["roundCostDigits"];
            this.contactAddressLevel = _data["contactAddressLevel"];
        }
    }

    static fromJS(data: any): GeneralSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["defaultTimeZone"] = this.defaultTimeZone;
        data["currencyId"] = this.currencyId;
        data["currencyCode"] = this.currencyCode;
        data["businessStartDate"] = this.businessStartDate ? this.businessStartDate.toISOString() : <any>undefined;
        data["roundTotalDigits"] = this.roundTotalDigits;
        data["roundCostDigits"] = this.roundCostDigits;
        data["contactAddressLevel"] = this.contactAddressLevel;
        return data;
    }

    clone(): GeneralSettingDto {
        const json = this.toJSON();
        let result = new GeneralSettingDto();
        result.init(json);
        return result;
    }
}

export interface IGeneralSettingDto {
    countryId: string | undefined;
    countryName: string | undefined;
    defaultTimeZone: string | undefined;
    currencyId: number | undefined;
    currencyCode: string | undefined;
    businessStartDate: moment.Moment | undefined;
    roundTotalDigits: number;
    roundCostDigits: number;
    contactAddressLevel: AddressLevel;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timezone = _data["timezone"];
            this.timezoneForComparison = _data["timezoneForComparison"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        return data;
    }

    clone(): GeneralSettingsEditDto {
        const json = this.toJSON();
        let result = new GeneralSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
    generalSetting: GeneralSettingDto;
    advanceSetting: AdvanceSettingDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
            this.generalSetting = _data["generalSetting"] ? GeneralSettingDto.fromJS(_data["generalSetting"]) : <any>undefined;
            this.advanceSetting = _data["advanceSetting"] ? AdvanceSettingDto.fromJS(_data["advanceSetting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["generalSetting"] = this.generalSetting ? this.generalSetting.toJSON() : <any>undefined;
        data["advanceSetting"] = this.advanceSetting ? this.advanceSetting.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
    generalSetting: GeneralSettingDto;
    advanceSetting: AdvanceSettingDto;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition: EditionEditDto;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionEditDto.fromJS(_data["edition"]) : <any>undefined;
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetEditionEditOutput {
        const json = this.toJSON();
        let result = new GetEditionEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"] ? ApplicationLanguageEditDto.fromJS(_data["language"]) : <any>undefined;
            if (Array.isArray(_data["languageNames"])) {
                this.languageNames = [] as any;
                for (let item of _data["languageNames"])
                    this.languageNames.push(ComboboxItemDto.fromJS(item));
            }
            if (Array.isArray(_data["flags"])) {
                this.flags = [] as any;
                for (let item of _data["flags"])
                    this.flags.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (Array.isArray(this.languageNames)) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (Array.isArray(this.flags)) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetLanguageForEditOutput {
        const json = this.toJSON();
        let result = new GetLanguageForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setting = _data["setting"] ? PasswordComplexitySetting.fromJS(_data["setting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetPasswordComplexitySettingOutput {
        const json = this.toJSON();
        let result = new GetPasswordComplexitySettingOutput();
        result.init(json);
        return result;
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: PermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(PermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: PermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetTenantFeaturesEditOutput {
        const json = this.toJSON();
        let result = new GetTenantFeaturesEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions: PermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(PermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }

    clone(): GetUserPermissionsForEditOutput {
        const json = this.toJSON();
        let result = new GetUserPermissionsForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions: PermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class GuidEntityDto implements IGuidEntityDto {
    id: string;

    constructor(data?: IGuidEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GuidEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new GuidEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): GuidEntityDto {
        const json = this.toJSON();
        let result = new GuidEntityDto();
        result.init(json);
        return result;
    }
}

export interface IGuidEntityDto {
    id: string;
}

export class GuidNullableFilterInputDto implements IGuidNullableFilterInputDto {
    exclude: boolean;
    ids: string[] | undefined;

    constructor(data?: IGuidNullableFilterInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exclude = _data["exclude"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
        }
    }

    static fromJS(data: any): GuidNullableFilterInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GuidNullableFilterInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exclude"] = this.exclude;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }

    clone(): GuidNullableFilterInputDto {
        const json = this.toJSON();
        let result = new GuidNullableFilterInputDto();
        result.init(json);
        return result;
    }
}

export interface IGuidNullableFilterInputDto {
    exclude: boolean;
    ids: string[] | undefined;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.legalName = _data["legalName"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data;
    }

    clone(): HostBillingSettingsEditDto {
        const json = this.toJSON();
        let result = new HostBillingSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.general = _data["general"] ? GeneralSettingsEditDto.fromJS(_data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = _data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(_data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = _data["email"] ? EmailSettingsEditDto.fromJS(_data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = _data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(_data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = _data["security"] ? SecuritySettingsEditDto.fromJS(_data["security"]) : new SecuritySettingsEditDto();
            this.billing = _data["billing"] ? HostBillingSettingsEditDto.fromJS(_data["billing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        return data;
    }

    clone(): HostSettingsEditDto {
        const json = this.toJSON();
        let result = new HostSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean;
    smsVerificationEnabled: boolean;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEmailConfirmationRequiredForLogin = _data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = _data["smsVerificationEnabled"];
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        return data;
    }

    clone(): HostUserManagementSettingsEditDto {
        const json = this.toJSON();
        let result = new HostUserManagementSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean;
    smsVerificationEnabled: boolean;
}

export class IValueValidator implements IIValueValidator {
    readonly name: string | undefined;
    readonly attributes: { [key: string]: any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (_data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>(<any>this).attributes)[key] = _data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = (<any>this.attributes)[key];
            }
        }
        return data;
    }

    clone(): IValueValidator {
        const json = this.toJSON();
        let result = new IValueValidator();
        result.init(json);
        return result;
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId: number | undefined;
    userId: number;

    constructor(data?: IImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data;
    }

    clone(): ImpersonateInput {
        const json = this.toJSON();
        let result = new ImpersonateInput();
        result.init(json);
        return result;
    }
}

export interface IImpersonateInput {
    tenantId: number | undefined;
    userId: number;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.impersonationToken = _data["impersonationToken"];
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data;
    }

    clone(): ImpersonateOutput {
        const json = this.toJSON();
        let result = new ImpersonateOutput();
        result.init(json);
        return result;
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data;
    }

    clone(): ImpersonatedAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export class Int64EntityDto implements IInt64EntityDto {
    id: number;

    constructor(data?: IInt64EntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Int64EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): Int64EntityDto {
        const json = this.toJSON();
        let result = new Int64EntityDto();
        result.init(json);
        return result;
    }
}

export interface IInt64EntityDto {
    id: number;
}

export class Int64FilterInputDto implements IInt64FilterInputDto {
    exclude: boolean;
    ids: number[] | undefined;

    constructor(data?: IInt64FilterInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exclude = _data["exclude"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
        }
    }

    static fromJS(data: any): Int64FilterInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64FilterInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exclude"] = this.exclude;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }

    clone(): Int64FilterInputDto {
        const json = this.toJSON();
        let result = new Int64FilterInputDto();
        result.init(json);
        return result;
    }
}

export interface IInt64FilterInputDto {
    exclude: boolean;
    ids: number[] | undefined;
}

export class Int64NullableFilterInputDto implements IInt64NullableFilterInputDto {
    exclude: boolean;
    ids: number[] | undefined;

    constructor(data?: IInt64NullableFilterInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exclude = _data["exclude"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
        }
    }

    static fromJS(data: any): Int64NullableFilterInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64NullableFilterInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exclude"] = this.exclude;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }

    clone(): Int64NullableFilterInputDto {
        const json = this.toJSON();
        let result = new Int64NullableFilterInputDto();
        result.init(json);
        return result;
    }
}

export interface IInt64NullableFilterInputDto {
    exclude: boolean;
    ids: number[] | undefined;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data;
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export enum JournalType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
    _15 = 15,
    _16 = 16,
    _17 = 17,
    _18 = 18,
    _19 = 19,
    _20 = 20,
    _21 = 21,
}

export class JournalTypeNameValueDto implements IJournalTypeNameValueDto {
    name: string | undefined;
    value: JournalType;

    constructor(data?: IJournalTypeNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): JournalTypeNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new JournalTypeNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }

    clone(): JournalTypeNameValueDto {
        const json = this.toJSON();
        let result = new JournalTypeNameValueDto();
        result.init(json);
        return result;
    }
}

export interface IJournalTypeNameValueDto {
    name: string | undefined;
    value: JournalType;
}

export class KhanDistrictDetailDto implements IKhanDistrictDetailDto {
    id: string;
    firstId: string | undefined;
    nextId: string | undefined;
    previousId: string | undefined;
    lastId: string | undefined;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    countryId: string | undefined;
    countryName: string | undefined;
    cityProvinceId: string | undefined;
    cityProvinceName: string | undefined;

    constructor(data?: IKhanDistrictDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstId = _data["firstId"];
            this.nextId = _data["nextId"];
            this.previousId = _data["previousId"];
            this.lastId = _data["lastId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModifierUserName = _data["lastModifierUserName"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.cannotEdit = _data["cannotEdit"];
            this.cannotDelete = _data["cannotDelete"];
            this.no = _data["no"];
            this.code = _data["code"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.cityProvinceId = _data["cityProvinceId"];
            this.cityProvinceName = _data["cityProvinceName"];
        }
    }

    static fromJS(data: any): KhanDistrictDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new KhanDistrictDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstId"] = this.firstId;
        data["nextId"] = this.nextId;
        data["previousId"] = this.previousId;
        data["lastId"] = this.lastId;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModifierUserName"] = this.lastModifierUserName;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["cannotEdit"] = this.cannotEdit;
        data["cannotDelete"] = this.cannotDelete;
        data["no"] = this.no;
        data["code"] = this.code;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["cityProvinceId"] = this.cityProvinceId;
        data["cityProvinceName"] = this.cityProvinceName;
        return data;
    }

    clone(): KhanDistrictDetailDto {
        const json = this.toJSON();
        let result = new KhanDistrictDetailDto();
        result.init(json);
        return result;
    }
}

export interface IKhanDistrictDetailDto {
    id: string;
    firstId: string | undefined;
    nextId: string | undefined;
    previousId: string | undefined;
    lastId: string | undefined;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    countryId: string | undefined;
    countryName: string | undefined;
    cityProvinceId: string | undefined;
    cityProvinceName: string | undefined;
}

export class KhanDistrictListDto implements IKhanDistrictListDto {
    id: string;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    countryName: string | undefined;
    cityProvinceName: string | undefined;

    constructor(data?: IKhanDistrictListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModifierUserName = _data["lastModifierUserName"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.cannotEdit = _data["cannotEdit"];
            this.cannotDelete = _data["cannotDelete"];
            this.no = _data["no"];
            this.code = _data["code"];
            this.countryName = _data["countryName"];
            this.cityProvinceName = _data["cityProvinceName"];
        }
    }

    static fromJS(data: any): KhanDistrictListDto {
        data = typeof data === 'object' ? data : {};
        let result = new KhanDistrictListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModifierUserName"] = this.lastModifierUserName;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["cannotEdit"] = this.cannotEdit;
        data["cannotDelete"] = this.cannotDelete;
        data["no"] = this.no;
        data["code"] = this.code;
        data["countryName"] = this.countryName;
        data["cityProvinceName"] = this.cityProvinceName;
        return data;
    }

    clone(): KhanDistrictListDto {
        const json = this.toJSON();
        let result = new KhanDistrictListDto();
        result.init(json);
        return result;
    }
}

export interface IKhanDistrictListDto {
    id: string;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    countryName: string | undefined;
    cityProvinceName: string | undefined;
}

export class KhanDistrictListDtoPagedResultDto implements IKhanDistrictListDtoPagedResultDto {
    items: KhanDistrictListDto[] | undefined;
    totalCount: number;

    constructor(data?: IKhanDistrictListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(KhanDistrictListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): KhanDistrictListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new KhanDistrictListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): KhanDistrictListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new KhanDistrictListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IKhanDistrictListDtoPagedResultDto {
    items: KhanDistrictListDto[] | undefined;
    totalCount: number;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.baseValue = _data["baseValue"];
            this.targetValue = _data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data;
    }

    clone(): LanguageTextListDto {
        const json = this.toJSON();
        let result = new LanguageTextListDto();
        result.init(json);
        return result;
    }
}

export interface ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;
}

export class LanguageTextListDtoPagedResultDto implements ILanguageTextListDtoPagedResultDto {
    items: LanguageTextListDto[] | undefined;
    totalCount: number;

    constructor(data?: ILanguageTextListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(LanguageTextListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LanguageTextListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): LanguageTextListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new LanguageTextListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ILanguageTextListDtoPagedResultDto {
    items: LanguageTextListDto[] | undefined;
    totalCount: number;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName: string | undefined;
    userNameOrEmailAddress: string;
    password: string;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        return data;
    }

    clone(): LinkToUserInput {
        const json = this.toJSON();
        let result = new LinkToUserInput();
        result.init(json);
        return result;
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    userNameOrEmailAddress: string;
    password: string;
}

export class LinkedUserDto implements ILinkedUserDto {
    id: number;
    tenantId: number | undefined;
    tenancyName: string | undefined;
    userName: string | undefined;
    lastLoginTime: moment.Moment | undefined;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.tenancyName = _data["tenancyName"];
            this.userName = _data["userName"];
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): LinkedUserDto {
        const json = this.toJSON();
        let result = new LinkedUserDto();
        result.init(json);
        return result;
    }
}

export interface ILinkedUserDto {
    id: number;
    tenantId: number | undefined;
    tenancyName: string | undefined;
    userName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
}

export class LinkedUserDtoListResultDto implements ILinkedUserDtoListResultDto {
    items: LinkedUserDto[] | undefined;

    constructor(data?: ILinkedUserDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LinkedUserDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): LinkedUserDtoListResultDto {
        const json = this.toJSON();
        let result = new LinkedUserDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface ILinkedUserDtoListResultDto {
    items: LinkedUserDto[] | undefined;
}

export class LinkedUserDtoPagedResultDto implements ILinkedUserDtoPagedResultDto {
    items: LinkedUserDto[] | undefined;
    totalCount: number;

    constructor(data?: ILinkedUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LinkedUserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): LinkedUserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new LinkedUserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ILinkedUserDtoPagedResultDto {
    items: LinkedUserDto[] | undefined;
    totalCount: number;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.displayText = _data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data;
    }

    clone(): LocalizableComboboxItemDto {
        const json = this.toJSON();
        let result = new LocalizableComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): LocalizableComboboxItemSourceDto {
        const json = this.toJSON();
        let result = new LocalizableComboboxItemSourceDto();
        result.init(json);
        return result;
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;
}

export class LocationDetailDto implements ILocationDetailDto {
    id: string;
    firstId: string | undefined;
    nextId: string | undefined;
    previousId: string | undefined;
    lastId: string | undefined;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    latitude: number | undefined;
    longitude: number | undefined;

    constructor(data?: ILocationDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstId = _data["firstId"];
            this.nextId = _data["nextId"];
            this.previousId = _data["previousId"];
            this.lastId = _data["lastId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModifierUserName = _data["lastModifierUserName"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.cannotEdit = _data["cannotEdit"];
            this.cannotDelete = _data["cannotDelete"];
            this.no = _data["no"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): LocationDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstId"] = this.firstId;
        data["nextId"] = this.nextId;
        data["previousId"] = this.previousId;
        data["lastId"] = this.lastId;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModifierUserName"] = this.lastModifierUserName;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["cannotEdit"] = this.cannotEdit;
        data["cannotDelete"] = this.cannotDelete;
        data["no"] = this.no;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }

    clone(): LocationDetailDto {
        const json = this.toJSON();
        let result = new LocationDetailDto();
        result.init(json);
        return result;
    }
}

export interface ILocationDetailDto {
    id: string;
    firstId: string | undefined;
    nextId: string | undefined;
    previousId: string | undefined;
    lastId: string | undefined;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    latitude: number | undefined;
    longitude: number | undefined;
}

export class LocationListDto implements ILocationListDto {
    id: string;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    latitude: number | undefined;
    longitude: number | undefined;

    constructor(data?: ILocationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModifierUserName = _data["lastModifierUserName"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.cannotEdit = _data["cannotEdit"];
            this.cannotDelete = _data["cannotDelete"];
            this.no = _data["no"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): LocationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModifierUserName"] = this.lastModifierUserName;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["cannotEdit"] = this.cannotEdit;
        data["cannotDelete"] = this.cannotDelete;
        data["no"] = this.no;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }

    clone(): LocationListDto {
        const json = this.toJSON();
        let result = new LocationListDto();
        result.init(json);
        return result;
    }
}

export interface ILocationListDto {
    id: string;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    latitude: number | undefined;
    longitude: number | undefined;
}

export class LocationListDtoPagedResultDto implements ILocationListDtoPagedResultDto {
    items: LocationListDto[] | undefined;
    totalCount: number;

    constructor(data?: ILocationListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(LocationListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LocationListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): LocationListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new LocationListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ILocationListDtoPagedResultDto {
    items: LocationListDto[] | undefined;
    totalCount: number;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id: number;
    newParentId: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.newParentId = _data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data;
    }

    clone(): MoveOrganizationUnitInput {
        const json = this.toJSON();
        let result = new MoveOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IMoveOrganizationUnitInput {
    id: number;
    newParentId: number | undefined;
}

export class NameValueDto implements INameValueDto {
    name: string | undefined;
    value: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }

    clone(): NameValueDto {
        const json = this.toJSON();
        let result = new NameValueDto();
        result.init(json);
        return result;
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class NameValueDtoListResultDto implements INameValueDtoListResultDto {
    items: NameValueDto[] | undefined;

    constructor(data?: INameValueDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NameValueDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): NameValueDtoListResultDto {
        const json = this.toJSON();
        let result = new NameValueDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface INameValueDtoListResultDto {
    items: NameValueDto[] | undefined;
}

export class NameValueDtoPagedResultDto implements INameValueDtoPagedResultDto {
    items: NameValueDto[] | undefined;
    totalCount: number;

    constructor(data?: INameValueDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): NameValueDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): NameValueDtoPagedResultDto {
        const json = this.toJSON();
        let result = new NameValueDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface INameValueDtoPagedResultDto {
    items: NameValueDto[] | undefined;
    totalCount: number;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.displayName = _data["displayName"];
            this.memberCount = _data["memberCount"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        return data;
    }

    clone(): OrganizationUnitDto {
        const json = this.toJSON();
        let result = new OrganizationUnitDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number;
}

export class OrganizationUnitDtoListResultDto implements IOrganizationUnitDtoListResultDto {
    items: OrganizationUnitDto[] | undefined;

    constructor(data?: IOrganizationUnitDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationUnitDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): OrganizationUnitDtoListResultDto {
        const json = this.toJSON();
        let result = new OrganizationUnitDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitDtoListResultDto {
    items: OrganizationUnitDto[] | undefined;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: moment.Moment;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.profilePictureId = _data["profilePictureId"];
            this.addedTime = _data["addedTime"] ? moment(_data["addedTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): OrganizationUnitUserListDto {
        const json = this.toJSON();
        let result = new OrganizationUnitUserListDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitUserListDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: moment.Moment;
}

export class OrganizationUnitUserListDtoPagedResultDto implements IOrganizationUnitUserListDtoPagedResultDto {
    items: OrganizationUnitUserListDto[] | undefined;
    totalCount: number;

    constructor(data?: IOrganizationUnitUserListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(OrganizationUnitUserListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): OrganizationUnitUserListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new OrganizationUnitUserListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitUserListDtoPagedResultDto {
    items: OrganizationUnitUserListDto[] | undefined;
    totalCount: number;
}

export class PageBranchInputDto implements IPageBranchInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;

    constructor(data?: IPageBranchInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.usePagination = _data["usePagination"];
            this.sortField = _data["sortField"];
            this.sortMode = _data["sortMode"];
            this.keyword = _data["keyword"];
            this.creators = _data["creators"] ? Int64NullableFilterInputDto.fromJS(_data["creators"]) : <any>undefined;
            this.modifiers = _data["modifiers"] ? Int64NullableFilterInputDto.fromJS(_data["modifiers"]) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PageBranchInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageBranchInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["usePagination"] = this.usePagination;
        data["sortField"] = this.sortField;
        data["sortMode"] = this.sortMode;
        data["keyword"] = this.keyword;
        data["creators"] = this.creators ? this.creators.toJSON() : <any>undefined;
        data["modifiers"] = this.modifiers ? this.modifiers.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): PageBranchInputDto {
        const json = this.toJSON();
        let result = new PageBranchInputDto();
        result.init(json);
        return result;
    }
}

export interface IPageBranchInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
}

export class PageCityProvinceInputDto implements IPageCityProvinceInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    countries: GuidNullableFilterInputDto;

    constructor(data?: IPageCityProvinceInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.usePagination = _data["usePagination"];
            this.sortField = _data["sortField"];
            this.sortMode = _data["sortMode"];
            this.keyword = _data["keyword"];
            this.creators = _data["creators"] ? Int64NullableFilterInputDto.fromJS(_data["creators"]) : <any>undefined;
            this.modifiers = _data["modifiers"] ? Int64NullableFilterInputDto.fromJS(_data["modifiers"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.countries = _data["countries"] ? GuidNullableFilterInputDto.fromJS(_data["countries"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PageCityProvinceInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageCityProvinceInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["usePagination"] = this.usePagination;
        data["sortField"] = this.sortField;
        data["sortMode"] = this.sortMode;
        data["keyword"] = this.keyword;
        data["creators"] = this.creators ? this.creators.toJSON() : <any>undefined;
        data["modifiers"] = this.modifiers ? this.modifiers.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["countries"] = this.countries ? this.countries.toJSON() : <any>undefined;
        return data;
    }

    clone(): PageCityProvinceInputDto {
        const json = this.toJSON();
        let result = new PageCityProvinceInputDto();
        result.init(json);
        return result;
    }
}

export interface IPageCityProvinceInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    countries: GuidNullableFilterInputDto;
}

export class PageCountryInputDto implements IPageCountryInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    currencies: Int64FilterInputDto;

    constructor(data?: IPageCountryInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.usePagination = _data["usePagination"];
            this.sortField = _data["sortField"];
            this.sortMode = _data["sortMode"];
            this.keyword = _data["keyword"];
            this.creators = _data["creators"] ? Int64NullableFilterInputDto.fromJS(_data["creators"]) : <any>undefined;
            this.modifiers = _data["modifiers"] ? Int64NullableFilterInputDto.fromJS(_data["modifiers"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.currencies = _data["currencies"] ? Int64FilterInputDto.fromJS(_data["currencies"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PageCountryInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageCountryInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["usePagination"] = this.usePagination;
        data["sortField"] = this.sortField;
        data["sortMode"] = this.sortMode;
        data["keyword"] = this.keyword;
        data["creators"] = this.creators ? this.creators.toJSON() : <any>undefined;
        data["modifiers"] = this.modifiers ? this.modifiers.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["currencies"] = this.currencies ? this.currencies.toJSON() : <any>undefined;
        return data;
    }

    clone(): PageCountryInputDto {
        const json = this.toJSON();
        let result = new PageCountryInputDto();
        result.init(json);
        return result;
    }
}

export interface IPageCountryInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    currencies: Int64FilterInputDto;
}

export class PageCurrencyInputDto implements IPageCurrencyInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;

    constructor(data?: IPageCurrencyInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.usePagination = _data["usePagination"];
            this.sortField = _data["sortField"];
            this.sortMode = _data["sortMode"];
            this.keyword = _data["keyword"];
            this.creators = _data["creators"] ? Int64NullableFilterInputDto.fromJS(_data["creators"]) : <any>undefined;
            this.modifiers = _data["modifiers"] ? Int64NullableFilterInputDto.fromJS(_data["modifiers"]) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PageCurrencyInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageCurrencyInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["usePagination"] = this.usePagination;
        data["sortField"] = this.sortField;
        data["sortMode"] = this.sortMode;
        data["keyword"] = this.keyword;
        data["creators"] = this.creators ? this.creators.toJSON() : <any>undefined;
        data["modifiers"] = this.modifiers ? this.modifiers.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): PageCurrencyInputDto {
        const json = this.toJSON();
        let result = new PageCurrencyInputDto();
        result.init(json);
        return result;
    }
}

export interface IPageCurrencyInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
}

export class PageKhanDistrictInputDto implements IPageKhanDistrictInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    countries: GuidNullableFilterInputDto;
    cityProvinces: GuidNullableFilterInputDto;

    constructor(data?: IPageKhanDistrictInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.usePagination = _data["usePagination"];
            this.sortField = _data["sortField"];
            this.sortMode = _data["sortMode"];
            this.keyword = _data["keyword"];
            this.creators = _data["creators"] ? Int64NullableFilterInputDto.fromJS(_data["creators"]) : <any>undefined;
            this.modifiers = _data["modifiers"] ? Int64NullableFilterInputDto.fromJS(_data["modifiers"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.countries = _data["countries"] ? GuidNullableFilterInputDto.fromJS(_data["countries"]) : <any>undefined;
            this.cityProvinces = _data["cityProvinces"] ? GuidNullableFilterInputDto.fromJS(_data["cityProvinces"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PageKhanDistrictInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageKhanDistrictInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["usePagination"] = this.usePagination;
        data["sortField"] = this.sortField;
        data["sortMode"] = this.sortMode;
        data["keyword"] = this.keyword;
        data["creators"] = this.creators ? this.creators.toJSON() : <any>undefined;
        data["modifiers"] = this.modifiers ? this.modifiers.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["countries"] = this.countries ? this.countries.toJSON() : <any>undefined;
        data["cityProvinces"] = this.cityProvinces ? this.cityProvinces.toJSON() : <any>undefined;
        return data;
    }

    clone(): PageKhanDistrictInputDto {
        const json = this.toJSON();
        let result = new PageKhanDistrictInputDto();
        result.init(json);
        return result;
    }
}

export interface IPageKhanDistrictInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    countries: GuidNullableFilterInputDto;
    cityProvinces: GuidNullableFilterInputDto;
}

export class PageLocationInputDto implements IPageLocationInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;

    constructor(data?: IPageLocationInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.usePagination = _data["usePagination"];
            this.sortField = _data["sortField"];
            this.sortMode = _data["sortMode"];
            this.keyword = _data["keyword"];
            this.creators = _data["creators"] ? Int64NullableFilterInputDto.fromJS(_data["creators"]) : <any>undefined;
            this.modifiers = _data["modifiers"] ? Int64NullableFilterInputDto.fromJS(_data["modifiers"]) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PageLocationInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageLocationInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["usePagination"] = this.usePagination;
        data["sortField"] = this.sortField;
        data["sortMode"] = this.sortMode;
        data["keyword"] = this.keyword;
        data["creators"] = this.creators ? this.creators.toJSON() : <any>undefined;
        data["modifiers"] = this.modifiers ? this.modifiers.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): PageLocationInputDto {
        const json = this.toJSON();
        let result = new PageLocationInputDto();
        result.init(json);
        return result;
    }
}

export interface IPageLocationInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
}

export class PageSangkatCommuneInputDto implements IPageSangkatCommuneInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    countries: GuidNullableFilterInputDto;
    cityProvinces: GuidNullableFilterInputDto;
    khanDistricts: GuidNullableFilterInputDto;

    constructor(data?: IPageSangkatCommuneInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.usePagination = _data["usePagination"];
            this.sortField = _data["sortField"];
            this.sortMode = _data["sortMode"];
            this.keyword = _data["keyword"];
            this.creators = _data["creators"] ? Int64NullableFilterInputDto.fromJS(_data["creators"]) : <any>undefined;
            this.modifiers = _data["modifiers"] ? Int64NullableFilterInputDto.fromJS(_data["modifiers"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.countries = _data["countries"] ? GuidNullableFilterInputDto.fromJS(_data["countries"]) : <any>undefined;
            this.cityProvinces = _data["cityProvinces"] ? GuidNullableFilterInputDto.fromJS(_data["cityProvinces"]) : <any>undefined;
            this.khanDistricts = _data["khanDistricts"] ? GuidNullableFilterInputDto.fromJS(_data["khanDistricts"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PageSangkatCommuneInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageSangkatCommuneInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["usePagination"] = this.usePagination;
        data["sortField"] = this.sortField;
        data["sortMode"] = this.sortMode;
        data["keyword"] = this.keyword;
        data["creators"] = this.creators ? this.creators.toJSON() : <any>undefined;
        data["modifiers"] = this.modifiers ? this.modifiers.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["countries"] = this.countries ? this.countries.toJSON() : <any>undefined;
        data["cityProvinces"] = this.cityProvinces ? this.cityProvinces.toJSON() : <any>undefined;
        data["khanDistricts"] = this.khanDistricts ? this.khanDistricts.toJSON() : <any>undefined;
        return data;
    }

    clone(): PageSangkatCommuneInputDto {
        const json = this.toJSON();
        let result = new PageSangkatCommuneInputDto();
        result.init(json);
        return result;
    }
}

export interface IPageSangkatCommuneInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    countries: GuidNullableFilterInputDto;
    cityProvinces: GuidNullableFilterInputDto;
    khanDistricts: GuidNullableFilterInputDto;
}

export class PageVillageInputDto implements IPageVillageInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    countries: GuidNullableFilterInputDto;
    cityProvinces: GuidNullableFilterInputDto;
    khanDistricts: GuidNullableFilterInputDto;
    sangkatCommunes: GuidNullableFilterInputDto;

    constructor(data?: IPageVillageInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.usePagination = _data["usePagination"];
            this.sortField = _data["sortField"];
            this.sortMode = _data["sortMode"];
            this.keyword = _data["keyword"];
            this.creators = _data["creators"] ? Int64NullableFilterInputDto.fromJS(_data["creators"]) : <any>undefined;
            this.modifiers = _data["modifiers"] ? Int64NullableFilterInputDto.fromJS(_data["modifiers"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.countries = _data["countries"] ? GuidNullableFilterInputDto.fromJS(_data["countries"]) : <any>undefined;
            this.cityProvinces = _data["cityProvinces"] ? GuidNullableFilterInputDto.fromJS(_data["cityProvinces"]) : <any>undefined;
            this.khanDistricts = _data["khanDistricts"] ? GuidNullableFilterInputDto.fromJS(_data["khanDistricts"]) : <any>undefined;
            this.sangkatCommunes = _data["sangkatCommunes"] ? GuidNullableFilterInputDto.fromJS(_data["sangkatCommunes"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PageVillageInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageVillageInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["usePagination"] = this.usePagination;
        data["sortField"] = this.sortField;
        data["sortMode"] = this.sortMode;
        data["keyword"] = this.keyword;
        data["creators"] = this.creators ? this.creators.toJSON() : <any>undefined;
        data["modifiers"] = this.modifiers ? this.modifiers.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["countries"] = this.countries ? this.countries.toJSON() : <any>undefined;
        data["cityProvinces"] = this.cityProvinces ? this.cityProvinces.toJSON() : <any>undefined;
        data["khanDistricts"] = this.khanDistricts ? this.khanDistricts.toJSON() : <any>undefined;
        data["sangkatCommunes"] = this.sangkatCommunes ? this.sangkatCommunes.toJSON() : <any>undefined;
        return data;
    }

    clone(): PageVillageInputDto {
        const json = this.toJSON();
        let result = new PageVillageInputDto();
        result.init(json);
        return result;
    }
}

export interface IPageVillageInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    creators: Int64NullableFilterInputDto;
    modifiers: Int64NullableFilterInputDto;
    isActive: boolean | undefined;
    countries: GuidNullableFilterInputDto;
    cityProvinces: GuidNullableFilterInputDto;
    khanDistricts: GuidNullableFilterInputDto;
    sangkatCommunes: GuidNullableFilterInputDto;
}

export class PagedActiveSortFilterInputDto implements IPagedActiveSortFilterInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    isActive: boolean | undefined;

    constructor(data?: IPagedActiveSortFilterInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.usePagination = _data["usePagination"];
            this.sortField = _data["sortField"];
            this.sortMode = _data["sortMode"];
            this.keyword = _data["keyword"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PagedActiveSortFilterInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedActiveSortFilterInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["usePagination"] = this.usePagination;
        data["sortField"] = this.sortField;
        data["sortMode"] = this.sortMode;
        data["keyword"] = this.keyword;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): PagedActiveSortFilterInputDto {
        const json = this.toJSON();
        let result = new PagedActiveSortFilterInputDto();
        result.init(json);
        return result;
    }
}

export interface IPagedActiveSortFilterInputDto {
    maxResultCount: number;
    skipCount: number;
    usePagination: boolean;
    sortField: string | undefined;
    sortMode: SortMode;
    keyword: string | undefined;
    isActive: boolean | undefined;
}

export class PagedLanguagesResultDto implements IPagedLanguagesResultDto {
    items: ApplicationLanguageListDto[] | undefined;
    totalCount: number;
    defaultLanguageName: string | undefined;

    constructor(data?: IPagedLanguagesResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ApplicationLanguageListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.defaultLanguageName = _data["defaultLanguageName"];
        }
    }

    static fromJS(data: any): PagedLanguagesResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedLanguagesResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["defaultLanguageName"] = this.defaultLanguageName;
        return data;
    }

    clone(): PagedLanguagesResultDto {
        const json = this.toJSON();
        let result = new PagedLanguagesResultDto();
        result.init(json);
        return result;
    }
}

export interface IPagedLanguagesResultDto {
    items: ApplicationLanguageListDto[] | undefined;
    totalCount: number;
    defaultLanguageName: string | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    readonly pattern: string | undefined;
    requireDigit: boolean;
    requireLowercase: boolean;
    requireNonAlphanumeric: boolean;
    requireUppercase: boolean;
    requiredLength: number;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).pattern = _data["pattern"];
            this.requireDigit = _data["requireDigit"];
            this.requireLowercase = _data["requireLowercase"];
            this.requireNonAlphanumeric = _data["requireNonAlphanumeric"];
            this.requireUppercase = _data["requireUppercase"];
            this.requiredLength = _data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pattern"] = this.pattern;
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data;
    }

    clone(): PasswordComplexitySetting {
        const json = this.toJSON();
        let result = new PasswordComplexitySetting();
        result.init(json);
        return result;
    }
}

export interface IPasswordComplexitySetting {
    pattern: string | undefined;
    requireDigit: boolean;
    requireLowercase: boolean;
    requireNonAlphanumeric: boolean;
    requireUppercase: boolean;
    requiredLength: number;
}

export class PermissionDto implements IPermissionDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    parent: PermissionDto;
    isGrantedByDefault: boolean;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.parent = _data["parent"] ? PermissionDto.fromJS(_data["parent"]) : <any>undefined;
            this.isGrantedByDefault = _data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data;
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    parent: PermissionDto;
    isGrantedByDefault: boolean;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IPermissionDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PermissionDtoListResultDto {
        const json = this.toJSON();
        let result = new PermissionDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data;
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminPassword = _data["adminPassword"];
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId: number;
    resetCode: string | undefined;
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
    c: string | undefined;
    captchaResponse: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.resetCode = _data["resetCode"];
            this.password = _data["password"];
            this.returnUrl = _data["returnUrl"];
            this.singleSignIn = _data["singleSignIn"];
            this.c = _data["c"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        data["c"] = this.c;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }

    clone(): ResetPasswordInput {
        const json = this.toJSON();
        let result = new ResetPasswordInput();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordInput {
    userId: number;
    resetCode: string | undefined;
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
    c: string | undefined;
    captchaResponse: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin: boolean;
    userName: string | undefined;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data;
    }

    clone(): ResetPasswordOutput {
        const json = this.toJSON();
        let result = new ResetPasswordOutput();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean;
    userName: string | undefined;
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c: string | undefined;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["c"] = this.c;
        return data;
    }

    clone(): ResolveTenantIdInput {
        const json = this.toJSON();
        let result = new ResolveTenantIdInput();
        result.init(json);
        return result;
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;
}

export class RoleDto implements IRoleDto {
    id: number;
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    id: number;
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoListResultDto {
    items: RoleDto[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
    items: RoleDto[] | undefined;
    totalCount: number;

    constructor(data?: IRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RoleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPagedResultDto {
    items: RoleDto[] | undefined;
    totalCount: number;
}

export class RoleEditDto implements IRoleEditDto {
    id: number;
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isStatic = _data["isStatic"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        return data;
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    id: number;
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
}

export class RoleListDto implements IRoleListDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleListDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export class SangkatCommuneDetailDto implements ISangkatCommuneDetailDto {
    id: string;
    firstId: string | undefined;
    nextId: string | undefined;
    previousId: string | undefined;
    lastId: string | undefined;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    countryId: string | undefined;
    countryName: string | undefined;
    cityProvinceId: string | undefined;
    cityProvinceName: string | undefined;
    khanDistrictId: string | undefined;
    khanDistrictName: string | undefined;

    constructor(data?: ISangkatCommuneDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstId = _data["firstId"];
            this.nextId = _data["nextId"];
            this.previousId = _data["previousId"];
            this.lastId = _data["lastId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModifierUserName = _data["lastModifierUserName"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.cannotEdit = _data["cannotEdit"];
            this.cannotDelete = _data["cannotDelete"];
            this.no = _data["no"];
            this.code = _data["code"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.cityProvinceId = _data["cityProvinceId"];
            this.cityProvinceName = _data["cityProvinceName"];
            this.khanDistrictId = _data["khanDistrictId"];
            this.khanDistrictName = _data["khanDistrictName"];
        }
    }

    static fromJS(data: any): SangkatCommuneDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new SangkatCommuneDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstId"] = this.firstId;
        data["nextId"] = this.nextId;
        data["previousId"] = this.previousId;
        data["lastId"] = this.lastId;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModifierUserName"] = this.lastModifierUserName;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["cannotEdit"] = this.cannotEdit;
        data["cannotDelete"] = this.cannotDelete;
        data["no"] = this.no;
        data["code"] = this.code;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["cityProvinceId"] = this.cityProvinceId;
        data["cityProvinceName"] = this.cityProvinceName;
        data["khanDistrictId"] = this.khanDistrictId;
        data["khanDistrictName"] = this.khanDistrictName;
        return data;
    }

    clone(): SangkatCommuneDetailDto {
        const json = this.toJSON();
        let result = new SangkatCommuneDetailDto();
        result.init(json);
        return result;
    }
}

export interface ISangkatCommuneDetailDto {
    id: string;
    firstId: string | undefined;
    nextId: string | undefined;
    previousId: string | undefined;
    lastId: string | undefined;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    countryId: string | undefined;
    countryName: string | undefined;
    cityProvinceId: string | undefined;
    cityProvinceName: string | undefined;
    khanDistrictId: string | undefined;
    khanDistrictName: string | undefined;
}

export class SangkatCommuneListDto implements ISangkatCommuneListDto {
    id: string;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    countryName: string | undefined;
    cityProvinceName: string | undefined;
    khanDistrictName: string | undefined;

    constructor(data?: ISangkatCommuneListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModifierUserName = _data["lastModifierUserName"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.cannotEdit = _data["cannotEdit"];
            this.cannotDelete = _data["cannotDelete"];
            this.no = _data["no"];
            this.code = _data["code"];
            this.countryName = _data["countryName"];
            this.cityProvinceName = _data["cityProvinceName"];
            this.khanDistrictName = _data["khanDistrictName"];
        }
    }

    static fromJS(data: any): SangkatCommuneListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SangkatCommuneListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModifierUserName"] = this.lastModifierUserName;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["cannotEdit"] = this.cannotEdit;
        data["cannotDelete"] = this.cannotDelete;
        data["no"] = this.no;
        data["code"] = this.code;
        data["countryName"] = this.countryName;
        data["cityProvinceName"] = this.cityProvinceName;
        data["khanDistrictName"] = this.khanDistrictName;
        return data;
    }

    clone(): SangkatCommuneListDto {
        const json = this.toJSON();
        let result = new SangkatCommuneListDto();
        result.init(json);
        return result;
    }
}

export interface ISangkatCommuneListDto {
    id: string;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    countryName: string | undefined;
    cityProvinceName: string | undefined;
    khanDistrictName: string | undefined;
}

export class SangkatCommuneListDtoPagedResultDto implements ISangkatCommuneListDtoPagedResultDto {
    items: SangkatCommuneListDto[] | undefined;
    totalCount: number;

    constructor(data?: ISangkatCommuneListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SangkatCommuneListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SangkatCommuneListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SangkatCommuneListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): SangkatCommuneListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new SangkatCommuneListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISangkatCommuneListDtoPagedResultDto {
    items: SangkatCommuneListDto[] | undefined;
    totalCount: number;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings: boolean;
    passwordComplexity: PasswordComplexitySetting;
    defaultPasswordComplexity: PasswordComplexitySetting;
    userLockOut: UserLockOutSettingsEditDto;
    twoFactorLogin: TwoFactorLoginSettingsEditDto;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.useDefaultPasswordComplexitySettings = _data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = _data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(_data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = _data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(_data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = _data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(_data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = _data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(_data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data;
    }

    clone(): SecuritySettingsEditDto {
        const json = this.toJSON();
        let result = new SecuritySettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings: boolean;
    passwordComplexity: PasswordComplexitySetting;
    defaultPasswordComplexity: PasswordComplexitySetting;
    userLockOut: UserLockOutSettingsEditDto;
    twoFactorLogin: TwoFactorLoginSettingsEditDto;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress: string;
    captchaResponse: string | undefined;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }

    clone(): SendPasswordResetCodeInput {
        const json = this.toJSON();
        let result = new SendPasswordResetCodeInput();
        result.init(json);
        return result;
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string;
    captchaResponse: string | undefined;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress: string;
    companyName: string | undefined;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.companyName = _data["companyName"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["companyName"] = this.companyName;
        return data;
    }

    clone(): SendTestEmailInput {
        const json = this.toJSON();
        let result = new SendTestEmailInput();
        result.init(json);
        return result;
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
    companyName: string | undefined;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }

    clone(): SetDefaultLanguageInput {
        const json = this.toJSON();
        let result = new SetDefaultLanguageInput();
        result.init(json);
        return result;
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

export enum SettingScopes {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _7 = 7,
}

export enum SortMode {
    _1 = 1,
    __1 = -1,
}

export class StringPagedResultDto implements IStringPagedResultDto {
    items: string[] | undefined;
    totalCount: number;

    constructor(data?: IStringPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(item);
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): StringPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StringPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): StringPagedResultDto {
        const json = this.toJSON();
        let result = new StringPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IStringPagedResultDto {
    items: string[] | undefined;
    totalCount: number;
}

export enum SubAccountType {
    _1000 = 1000,
    _1001 = 1001,
    _1002 = 1002,
    _1003 = 1003,
    _1004 = 1004,
    _1100 = 1100,
    _1101 = 1101,
    _1200 = 1200,
    _1300 = 1300,
    _1400 = 1400,
    _1401 = 1401,
    _1402 = 1402,
    _1403 = 1403,
    _1404 = 1404,
    _1405 = 1405,
    _1406 = 1406,
    _1407 = 1407,
    _1408 = 1408,
    _1409 = 1409,
    _1410 = 1410,
    _1411 = 1411,
    _1500 = 1500,
    _1501 = 1501,
    _1502 = 1502,
    _1503 = 1503,
    _1504 = 1504,
    _1505 = 1505,
    _1506 = 1506,
    _1507 = 1507,
    _1508 = 1508,
    _1509 = 1509,
    _1600 = 1600,
    _1601 = 1601,
    _1602 = 1602,
    _1603 = 1603,
    _1604 = 1604,
    _1605 = 1605,
    _1606 = 1606,
    _1607 = 1607,
    _1608 = 1608,
    _1609 = 1609,
    _1610 = 1610,
    _2000 = 2000,
    _2100 = 2100,
    _2200 = 2200,
    _2201 = 2201,
    _2202 = 2202,
    _2203 = 2203,
    _2204 = 2204,
    _2205 = 2205,
    _2206 = 2206,
    _2207 = 2207,
    _2208 = 2208,
    _2209 = 2209,
    _2210 = 2210,
    _2211 = 2211,
    _2212 = 2212,
    _2213 = 2213,
    _2214 = 2214,
    _2300 = 2300,
    _2301 = 2301,
    _2302 = 2302,
    _2303 = 2303,
    _2304 = 2304,
    _2305 = 2305,
    _2306 = 2306,
    _3000 = 3000,
    _3001 = 3001,
    _3002 = 3002,
    _3003 = 3003,
    _3004 = 3004,
    _3005 = 3005,
    _3006 = 3006,
    _3007 = 3007,
    _3008 = 3008,
    _3009 = 3009,
    _3010 = 3010,
    _3011 = 3011,
    _3012 = 3012,
    _3013 = 3013,
    _3014 = 3014,
    _4000 = 4000,
    _4001 = 4001,
    _4002 = 4002,
    _4003 = 4003,
    _4004 = 4004,
    _4005 = 4005,
    _4006 = 4006,
    _4007 = 4007,
    _4008 = 4008,
    _4100 = 4100,
    _4101 = 4101,
    _4102 = 4102,
    _4103 = 4103,
    _4104 = 4104,
    _4105 = 4105,
    _4106 = 4106,
    _4107 = 4107,
    _5000 = 5000,
    _5001 = 5001,
    _5002 = 5002,
    _5003 = 5003,
    _5004 = 5004,
    _5100 = 5100,
    _5101 = 5101,
    _5102 = 5102,
    _5103 = 5103,
    _5104 = 5104,
    _5105 = 5105,
    _5106 = 5106,
    _5107 = 5107,
    _5108 = 5108,
    _5109 = 5109,
    _5110 = 5110,
    _5111 = 5111,
    _5112 = 5112,
    _5113 = 5113,
    _5114 = 5114,
    _5115 = 5115,
    _5116 = 5116,
    _5117 = 5117,
    _5118 = 5118,
    _5119 = 5119,
    _5120 = 5120,
    _5121 = 5121,
    _5122 = 5122,
    _5123 = 5123,
    _5124 = 5124,
    _5125 = 5125,
    _5126 = 5126,
    _5127 = 5127,
    _5128 = 5128,
    _5129 = 5129,
    _5130 = 5130,
    _5200 = 5200,
    _5201 = 5201,
    _5202 = 5202,
    _5203 = 5203,
    _5204 = 5204,
}

export class SubAccountTypeFilterInputDto implements ISubAccountTypeFilterInputDto {
    exclude: boolean;
    ids: SubAccountType[] | undefined;

    constructor(data?: ISubAccountTypeFilterInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exclude = _data["exclude"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids.push(item);
            }
        }
    }

    static fromJS(data: any): SubAccountTypeFilterInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubAccountTypeFilterInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exclude"] = this.exclude;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }

    clone(): SubAccountTypeFilterInputDto {
        const json = this.toJSON();
        let result = new SubAccountTypeFilterInputDto();
        result.init(json);
        return result;
    }
}

export interface ISubAccountTypeFilterInputDto {
    exclude: boolean;
    ids: SubAccountType[] | undefined;
}

export class SubAccountTypeNameValueDto implements ISubAccountTypeNameValueDto {
    name: string | undefined;
    value: SubAccountType;

    constructor(data?: ISubAccountTypeNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SubAccountTypeNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubAccountTypeNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }

    clone(): SubAccountTypeNameValueDto {
        const json = this.toJSON();
        let result = new SubAccountTypeNameValueDto();
        result.init(json);
        return result;
    }
}

export interface ISubAccountTypeNameValueDto {
    name: string | undefined;
    value: SubAccountType;
}

export class SubAccountTypeNameValueDtoListResultDto implements ISubAccountTypeNameValueDtoListResultDto {
    items: SubAccountTypeNameValueDto[] | undefined;

    constructor(data?: ISubAccountTypeNameValueDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SubAccountTypeNameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubAccountTypeNameValueDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubAccountTypeNameValueDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): SubAccountTypeNameValueDtoListResultDto {
        const json = this.toJSON();
        let result = new SubAccountTypeNameValueDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface ISubAccountTypeNameValueDtoListResultDto {
    items: SubAccountTypeNameValueDto[] | undefined;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetTenantId = _data["targetTenantId"];
            this.targetUserId = _data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data;
    }

    clone(): SwitchToLinkedAccountInput {
        const json = this.toJSON();
        let result = new SwitchToLinkedAccountInput();
        result.init(json);
        return result;
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.switchAccountToken = _data["switchAccountToken"];
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data;
    }

    clone(): SwitchToLinkedAccountOutput {
        const json = this.toJSON();
        let result = new SwitchToLinkedAccountOutput();
        result.init(json);
        return result;
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data;
    }

    clone(): SwitchedAccountAuthenticateResultModel {
        const json = this.toJSON();
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export enum TenantAvailabilityState {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class TenantDto implements ITenantDto {
    id: number;
    tenancyName: string;
    name: string;
    isActive: boolean;
    editionId: number | undefined;
    editionName: string | undefined;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.editionId = _data["editionId"];
            this.editionName = _data["editionName"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["editionId"] = this.editionId;
        data["editionName"] = this.editionName;
        return data;
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    id: number;
    tenancyName: string;
    name: string;
    isActive: boolean;
    editionId: number | undefined;
    editionName: string | undefined;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    items: TenantDto[] | undefined;
    totalCount: number;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    items: TenantDto[] | undefined;
    totalCount: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    id: number;
    tenancyName: string | undefined;
    name: string | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        return data;
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    id: number;
    tenancyName: string | undefined;
    name: string | undefined;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredTenantActiveByDefault: boolean;
    useCaptchaOnRegistration: boolean;
    defaultEditionId: number | undefined;
    defaultEditionName: string | undefined;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowSelfRegistration = _data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = _data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = _data["useCaptchaOnRegistration"];
            this.defaultEditionId = _data["defaultEditionId"];
            this.defaultEditionName = _data["defaultEditionName"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        data["defaultEditionName"] = this.defaultEditionName;
        return data;
    }

    clone(): TenantManagementSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantManagementSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredTenantActiveByDefault: boolean;
    useCaptchaOnRegistration: boolean;
    defaultEditionId: number | undefined;
    defaultEditionName: string | undefined;
}

export class TestModelOutput implements ITestModelOutput {
    id: string;
    date: moment.Moment;
    dateIndex: moment.Moment;
    name: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    rowNumber: number;
    totalRecords: number;

    constructor(data?: ITestModelOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.dateIndex = _data["dateIndex"] ? moment(_data["dateIndex"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.rowNumber = _data["rowNumber"];
            this.totalRecords = _data["totalRecords"];
        }
    }

    static fromJS(data: any): TestModelOutput {
        data = typeof data === 'object' ? data : {};
        let result = new TestModelOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["dateIndex"] = this.dateIndex ? this.dateIndex.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["rowNumber"] = this.rowNumber;
        data["totalRecords"] = this.totalRecords;
        return data;
    }

    clone(): TestModelOutput {
        const json = this.toJSON();
        let result = new TestModelOutput();
        result.init(json);
        return result;
    }
}

export interface ITestModelOutput {
    id: string;
    date: moment.Moment;
    dateIndex: moment.Moment;
    name: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    rowNumber: number;
    totalRecords: number;
}

export class TransactionNoSettingDto implements ITransactionNoSettingDto {
    id: string | undefined;
    journalType: JournalType;
    journalTypeName: string | undefined;
    customTransactionNoEnable: boolean;
    prefix: string | undefined;
    digits: number;
    start: number;
    requiredReference: boolean;

    constructor(data?: ITransactionNoSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.journalType = _data["journalType"];
            this.journalTypeName = _data["journalTypeName"];
            this.customTransactionNoEnable = _data["customTransactionNoEnable"];
            this.prefix = _data["prefix"];
            this.digits = _data["digits"];
            this.start = _data["start"];
            this.requiredReference = _data["requiredReference"];
        }
    }

    static fromJS(data: any): TransactionNoSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionNoSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["journalType"] = this.journalType;
        data["journalTypeName"] = this.journalTypeName;
        data["customTransactionNoEnable"] = this.customTransactionNoEnable;
        data["prefix"] = this.prefix;
        data["digits"] = this.digits;
        data["start"] = this.start;
        data["requiredReference"] = this.requiredReference;
        return data;
    }

    clone(): TransactionNoSettingDto {
        const json = this.toJSON();
        let result = new TransactionNoSettingDto();
        result.init(json);
        return result;
    }
}

export interface ITransactionNoSettingDto {
    id: string | undefined;
    journalType: JournalType;
    journalTypeName: string | undefined;
    customTransactionNoEnable: boolean;
    prefix: string | undefined;
    digits: number;
    start: number;
    requiredReference: boolean;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean;
    isEnabled: boolean;
    isEmailProviderEnabled: boolean;
    isSmsProviderEnabled: boolean;
    isRememberBrowserEnabled: boolean;
    isGoogleAuthenticatorEnabled: boolean;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabledForApplication = _data["isEnabledForApplication"];
            this.isEnabled = _data["isEnabled"];
            this.isEmailProviderEnabled = _data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = _data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = _data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = _data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data;
    }

    clone(): TwoFactorLoginSettingsEditDto {
        const json = this.toJSON();
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean;
    isEnabled: boolean;
    isEmailProviderEnabled: boolean;
    isSmsProviderEnabled: boolean;
    isRememberBrowserEnabled: boolean;
    isGoogleAuthenticatorEnabled: boolean;
}

export class UnitDto implements IUnitDto {
    id: string;
    name: string | undefined;

    constructor(data?: IUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): UnitDto {
        const json = this.toJSON();
        let result = new UnitDto();
        result.init(json);
        return result;
    }
}

export interface IUnitDto {
    id: string;
    name: string | undefined;
}

export class UnitDtoPagedResultDto implements IUnitDtoPagedResultDto {
    items: UnitDto[] | undefined;
    totalCount: number;

    constructor(data?: IUnitDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UnitDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UnitDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnitDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): UnitDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UnitDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUnitDtoPagedResultDto {
    items: UnitDto[] | undefined;
    totalCount: number;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data;
    }

    clone(): UnlinkUserInput {
        const json = this.toJSON();
        let result = new UnlinkUserInput();
        result.init(json);
        return result;
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number;
}

export class UpdateGoogleAuthenticatorKeyOutput implements IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;

    constructor(data?: IUpdateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.qrCodeSetupImageUrl = _data["qrCodeSetupImageUrl"];
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        return data;
    }

    clone(): UpdateGoogleAuthenticatorKeyOutput {
        const json = this.toJSON();
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(json);
        return result;
    }
}

export interface IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
            this.sourceName = _data["sourceName"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }

    clone(): UpdateLanguageTextInput {
        const json = this.toJSON();
        let result = new UpdateLanguageTextInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;
}

export class UpdateLogoInput implements IUpdateLogoInput {
    logoId: string;

    constructor(data?: IUpdateLogoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.logoId = _data["logoId"];
        }
    }

    static fromJS(data: any): UpdateLogoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLogoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["logoId"] = this.logoId;
        return data;
    }

    clone(): UpdateLogoInput {
        const json = this.toJSON();
        let result = new UpdateLogoInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateLogoInput {
    logoId: string;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id: number;
    displayName: string;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }

    clone(): UpdateOrganizationUnitInput {
        const json = this.toJSON();
        let result = new UpdateOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number;
    displayName: string;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id: number;
    featureValues: NameValueDto[];

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpdateTenantFeaturesInput {
        const json = this.toJSON();
        let result = new UpdateTenantFeaturesInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number;
    featureValues: NameValueDto[];
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id: number;
    grantedPermissionNames: string[];

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }

    clone(): UpdateUserPermissionsInput {
        const json = this.toJSON();
        let result = new UpdateUserPermissionsInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserPermissionsInput {
    id: number;
    grantedPermissionNames: string[];
}

export class UserDto implements IUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    isDeactivate: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    useEmail: boolean;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.isDeactivate = _data["isDeactivate"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.useEmail = _data["useEmail"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["isDeactivate"] = this.isDeactivate;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["useEmail"] = this.useEmail;
        return data;
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    isDeactivate: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    useEmail: boolean;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    items: UserDto[] | undefined;
    totalCount: number;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): UserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPagedResultDto {
    items: UserDto[] | undefined;
    totalCount: number;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled: boolean;
    maxFailedAccessAttemptsBeforeLockout: number;
    defaultAccountLockoutSeconds: number;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = _data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = _data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data;
    }

    clone(): UserLockOutSettingsEditDto {
        const json = this.toJSON();
        let result = new UserLockOutSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled: boolean;
    maxFailedAccessAttemptsBeforeLockout: number;
    defaultAccountLockoutSeconds: number;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmailAddress: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.result = _data["result"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): UserLoginAttemptDto {
        const json = this.toJSON();
        let result = new UserLoginAttemptDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmailAddress: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment;
}

export class UserLoginAttemptDtoListResultDto implements IUserLoginAttemptDtoListResultDto {
    items: UserLoginAttemptDto[] | undefined;

    constructor(data?: IUserLoginAttemptDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserLoginAttemptDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): UserLoginAttemptDtoListResultDto {
        const json = this.toJSON();
        let result = new UserLoginAttemptDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginAttemptDtoListResultDto {
    items: UserLoginAttemptDto[] | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.profilePictureId = _data["profilePictureId"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        return data;
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
}

export class UserSummaryDto implements IUserSummaryDto {
    id: number;
    userName: string | undefined;
    useEmail: boolean;
    emailAddress: string | undefined;
    fullName: string | undefined;

    constructor(data?: IUserSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.useEmail = _data["useEmail"];
            this.emailAddress = _data["emailAddress"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): UserSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["useEmail"] = this.useEmail;
        data["emailAddress"] = this.emailAddress;
        data["fullName"] = this.fullName;
        return data;
    }

    clone(): UserSummaryDto {
        const json = this.toJSON();
        let result = new UserSummaryDto();
        result.init(json);
        return result;
    }
}

export interface IUserSummaryDto {
    id: number;
    userName: string | undefined;
    useEmail: boolean;
    emailAddress: string | undefined;
    fullName: string | undefined;
}

export class UserSummaryDtoPagedResultDto implements IUserSummaryDtoPagedResultDto {
    items: UserSummaryDto[] | undefined;
    totalCount: number;

    constructor(data?: IUserSummaryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserSummaryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UserSummaryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserSummaryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): UserSummaryDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserSummaryDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserSummaryDtoPagedResultDto {
    items: UserSummaryDto[] | undefined;
    totalCount: number;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds.push(item);
            }
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }

    clone(): UsersToOrganizationUnitInput {
        const json = this.toJSON();
        let result = new UsersToOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code: string | undefined;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        return data;
    }

    clone(): VerifySmsCodeInputDto {
        const json = this.toJSON();
        let result = new VerifySmsCodeInputDto();
        result.init(json);
        return result;
    }
}

export interface IVerifySmsCodeInputDto {
    code: string | undefined;
}

export class VillageDetailDto implements IVillageDetailDto {
    id: string;
    firstId: string | undefined;
    nextId: string | undefined;
    previousId: string | undefined;
    lastId: string | undefined;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    countryId: string | undefined;
    countryName: string | undefined;
    cityProvinceId: string | undefined;
    cityProvinceName: string | undefined;
    khanDistrictId: string | undefined;
    khanDistrictName: string | undefined;
    sangkatCommuneId: string | undefined;
    sangkatCommuneName: string | undefined;

    constructor(data?: IVillageDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstId = _data["firstId"];
            this.nextId = _data["nextId"];
            this.previousId = _data["previousId"];
            this.lastId = _data["lastId"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModifierUserName = _data["lastModifierUserName"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.cannotEdit = _data["cannotEdit"];
            this.cannotDelete = _data["cannotDelete"];
            this.no = _data["no"];
            this.code = _data["code"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.cityProvinceId = _data["cityProvinceId"];
            this.cityProvinceName = _data["cityProvinceName"];
            this.khanDistrictId = _data["khanDistrictId"];
            this.khanDistrictName = _data["khanDistrictName"];
            this.sangkatCommuneId = _data["sangkatCommuneId"];
            this.sangkatCommuneName = _data["sangkatCommuneName"];
        }
    }

    static fromJS(data: any): VillageDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new VillageDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstId"] = this.firstId;
        data["nextId"] = this.nextId;
        data["previousId"] = this.previousId;
        data["lastId"] = this.lastId;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModifierUserName"] = this.lastModifierUserName;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["cannotEdit"] = this.cannotEdit;
        data["cannotDelete"] = this.cannotDelete;
        data["no"] = this.no;
        data["code"] = this.code;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["cityProvinceId"] = this.cityProvinceId;
        data["cityProvinceName"] = this.cityProvinceName;
        data["khanDistrictId"] = this.khanDistrictId;
        data["khanDistrictName"] = this.khanDistrictName;
        data["sangkatCommuneId"] = this.sangkatCommuneId;
        data["sangkatCommuneName"] = this.sangkatCommuneName;
        return data;
    }

    clone(): VillageDetailDto {
        const json = this.toJSON();
        let result = new VillageDetailDto();
        result.init(json);
        return result;
    }
}

export interface IVillageDetailDto {
    id: string;
    firstId: string | undefined;
    nextId: string | undefined;
    previousId: string | undefined;
    lastId: string | undefined;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    countryId: string | undefined;
    countryName: string | undefined;
    cityProvinceId: string | undefined;
    cityProvinceName: string | undefined;
    khanDistrictId: string | undefined;
    khanDistrictName: string | undefined;
    sangkatCommuneId: string | undefined;
    sangkatCommuneName: string | undefined;
}

export class VillageListDto implements IVillageListDto {
    id: string;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    countryName: string | undefined;
    cityProvinceName: string | undefined;
    khanDistrictName: string | undefined;
    sangkatCommuneName: string | undefined;

    constructor(data?: IVillageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUserName = _data["creatorUserName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModifierUserName = _data["lastModifierUserName"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.cannotEdit = _data["cannotEdit"];
            this.cannotDelete = _data["cannotDelete"];
            this.no = _data["no"];
            this.code = _data["code"];
            this.countryName = _data["countryName"];
            this.cityProvinceName = _data["cityProvinceName"];
            this.khanDistrictName = _data["khanDistrictName"];
            this.sangkatCommuneName = _data["sangkatCommuneName"];
        }
    }

    static fromJS(data: any): VillageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new VillageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModifierUserName"] = this.lastModifierUserName;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["cannotEdit"] = this.cannotEdit;
        data["cannotDelete"] = this.cannotDelete;
        data["no"] = this.no;
        data["code"] = this.code;
        data["countryName"] = this.countryName;
        data["cityProvinceName"] = this.cityProvinceName;
        data["khanDistrictName"] = this.khanDistrictName;
        data["sangkatCommuneName"] = this.sangkatCommuneName;
        return data;
    }

    clone(): VillageListDto {
        const json = this.toJSON();
        let result = new VillageListDto();
        result.init(json);
        return result;
    }
}

export interface IVillageListDto {
    id: string;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    lastModifierUserName: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    isActive: boolean;
    name: string | undefined;
    displayName: string | undefined;
    cannotEdit: boolean;
    cannotDelete: boolean;
    no: number;
    code: string | undefined;
    countryName: string | undefined;
    cityProvinceName: string | undefined;
    khanDistrictName: string | undefined;
    sangkatCommuneName: string | undefined;
}

export class VillageListDtoPagedResultDto implements IVillageListDtoPagedResultDto {
    items: VillageListDto[] | undefined;
    totalCount: number;

    constructor(data?: IVillageListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(VillageListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): VillageListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new VillageListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): VillageListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new VillageListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IVillageListDtoPagedResultDto {
    items: VillageListDto[] | undefined;
    totalCount: number;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
